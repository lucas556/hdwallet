<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>多链 xprv/xpub 与地址推导（BIP39 → BIP32，纯前端）</title>
<style>
  :root{--bg:#0b1220;--card:#0f1724;--line:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--good:#10b981;--bad:#ef4444}
  html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif}
  .wrap{max-width:980px;margin:32px auto;padding:0 16px}
  h1{margin:0 0 12px}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:18px;margin:14px 0;box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .row{display:flex;flex-wrap:wrap;gap:10px;margin:10px 0;align-items:center}
  .muted{color:var(--muted)}
  input,select,button,textarea{
    background:#0c152a;border:1px solid #243250;color:var(--text);
    border-radius:10px;padding:10px 12px
  }
  button{cursor:pointer}
  button:hover{filter:brightness(1.08)}
  pre{
    background:#0a1224;border:1px solid #1d2a44;border-radius:10px;padding:12px;
    max-width:100%;white-space:pre-wrap;word-break:break-all;overflow-wrap:anywhere;overflow:auto
  }
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .ok{color:var(--good)} .err{color:var(--bad)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="wrap">
  <h1>多链推导：助记词 → Seed → xprv/xpub → 地址</h1>
  <div class="muted">支持：BTC（BIP84、bc1q/bech32、zprv/zpub）、ETH（EIP-55）、TRON（Base58Check）、EOS（legacy “EOS…” 公钥）。</div>

  <!-- 生成助记词 -->
  <div class="card">
    <h3>① 生成助记词 & Seed</h3>
    <div class="row">
      <label>词数：
        <select id="sl-words">
          <option value="128">12 词（128-bit ENT）</option>
          <option value="256">24 词（256-bit ENT）</option>
        </select>
      </label>
      <label>可选 passphrase：
        <input id="in-pass" placeholder="推荐留空（BIP39 passphrase）"/>
      </label>
      <button id="btn-gen" disabled>生成助记词并推导 Seed</button>
      <span id="mn-tip" class="muted"></span>
    </div>
    <div id="mnemo-box" style="display:none">
      <div class="row"><b>助记词：</b></div>
      <pre id="out-mnemonic" class="mono"></pre>
      <div class="row"><b>Seed（64 字节十六进制）：</b></div>
      <pre id="out-seed" class="mono"></pre>
    </div>
  </div>

  <!-- 选择链并导出 -->
  <div class="card">
    <h3>② 选择链 → 导出账户 xprv/xpub 与地址</h3>
    <div class="row">
      <label>链：
        <select id="sl-chain" disabled>
          <option value="btc">BTC（BIP84 / zprv & zpub / bech32）</option>
          <option value="eth">ETH（EIP-55 地址）</option>
          <option value="tron">TRON（Base58Check 地址）</option>
          <option value="eos">EOS（legacy “EOS…” 公钥）</option>
        </select>
      </label>
      <label>索引（第几个地址）：
        <input id="in-index" type="number" min="0" value="0" style="width:120px"/>
      </label>
      <button id="btn-derive" disabled>导出账户 xprv/xpub 与地址</button>
      <span id="drv-tip" class="muted"></span>
    </div>

    <div id="out-box" style="display:none">
      <div class="row"><b class="mono" id="out-path-title"></b></div>
      <div class="grid">
        <div>
          <div class="row"><b>账户扩展私钥：</b></div>
          <pre id="out-xprv" class="mono"></pre>
        </div>
        <div>
          <div class="row"><b>账户扩展公钥：</b></div>
          <pre id="out-xpub" class="mono"></pre>
        </div>
      </div>

      <div class="row"><b>派生地址（index = <span id="out-idx">0</span>）：</b></div>
      <pre id="out-addr" class="mono"></pre>
    </div>
  </div>
</div>

<script type="module">
/* ===== 依赖（ESM） ===== */
import * as secp from 'https://esm.run/@noble/secp256k1@1.7.1';
import { ripemd160 } from 'https://esm.run/@noble/hashes@1.4.0/ripemd160';
import { keccak_256 } from 'https://esm.sh/@noble/hashes@1.4.0/sha3';

/* ===== 工具 ===== */
function bytesToHex(u8){ let s=''; for (let i=0;i<u8.length;i++) s+=u8[i].toString(16).padStart(2,'0'); return s; }
function hexToBytes(hex){ const h=hex.replace(/^0x/i,''); const out=new Uint8Array(h.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(h.slice(i*2,i*2+2),16); return out; }
const te = new TextEncoder(), td = new TextDecoder();
const $ = id => document.getElementById(id);
const curveN = secp.CURVE.n;

/* WebCrypto SHA-256 / HMAC-SHA512 / PBKDF2 */
async function wc_sha256(bytes){ const out=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(out); }
async function hmacSHA512(keyBytes, dataBytes){
  const key = await crypto.subtle.importKey('raw', keyBytes, {name:'HMAC', hash:'SHA-512'}, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', key, dataBytes);
  return new Uint8Array(sig);
}
async function pbkdf2_sha512(passwordBytes, saltBytes, iterations, dkLen){
  const key = await crypto.subtle.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);
  const bits = await crypto.subtle.deriveBits({ name: 'PBKDF2', hash:'SHA-512', salt: saltBytes, iterations }, key, dkLen*8);
  return new Uint8Array(bits);
}

/* Base58 / Base58Check */
const ALPH='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function b58encode(data){
  let x = BigInt('0x'+bytesToHex(data)), out='';
  while (x>0n){ const m = x % 58n; out = ALPH[Number(m)] + out; x = x / 58n; }
  for (let i=0;i<data.length && data[i]===0;i++) out='1'+out;
  return out || '1';
}
async function b58check(payload){
  const s1 = await wc_sha256(payload);
  const s2 = await wc_sha256(s1);
  const chk = s2.slice(0,4);
  return b58encode(new Uint8Array([...payload, ...chk]));
}

/* bech32（简实现，v0 P2WPKH） */
const BECH32_ALPH='qpzry9x8gf2tvdw0s3jn54khce6mua7l';
function bech32_polymod(values){
  const GEN=[0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];
  let chk=1;
  for(const v of values){
    const b=chk>>25;
    chk=(chk & 0x1ffffff) << 5 ^ v;
    for(let i=0;i<5;i++) if((b>>i)&1) chk ^= GEN[i];
  }
  return chk;
}
function bech32_hrp_expand(hrp){
  const out=[]; for(let i=0;i<hrp.length;i++) out.push(hrp.charCodeAt(i)>>5);
  out.push(0);
  for(let i=0;i<hrp.length;i++) out.push(hrp.charCodeAt(i)&31);
  return out;
}
function bech32_create_checksum(hrp, data){
  const values = bech32_hrp_expand(hrp).concat(data).concat([0,0,0,0,0,0]);
  const mod = bech32_polymod(values) ^ 1;
  const out=[]; for(let p=0;p<6;p++) out.push((mod >> 5*(5-p)) & 31);
  return out;
}
function bech32_encode(hrp, data){
  const enc = data.concat(bech32_create_checksum(hrp,data)).map(v=>BECH32_ALPH[v]).join('');
  return hrp + '1' + enc;
}
function convertbits(data, from, to, pad=true){
  let acc=0, bits=0; const ret=[]; const maxv=(1<<to)-1;
  for(const v of data){
    if (v<0 || v>>from) return null;
    acc = (acc << from) | v; bits += from;
    while(bits >= to){ bits -= to; ret.push((acc >> bits) & maxv); }
  }
  if (pad){ if(bits) ret.push((acc << (to - bits)) & maxv); }
  else if (bits >= from || ((acc << (to - bits)) & maxv)) return null;
  return ret;
}

/* BIP39 词表（静默加载 + 校验） */
const WORD_HASH_EXPECT='2f5eed53a4727b4bf8880d8f3f199efc90e58503646d9ff8eff3a2ed3b24dbda';
let WORDS=null;
async function loadWordlistOnce(){
  if(WORDS) return WORDS;
  const res=await fetch('./english.txt');
  const buf=new Uint8Array(await res.arrayBuffer());
  const h = bytesToHex(await wc_sha256(buf));
  if (h!==WORD_HASH_EXPECT) throw new Error('english.txt SHA-256 校验失败');
  WORDS = td.decode(buf).replace(/\r/g,'').trim().split('\n');
  return WORDS;
}
function bytesToBits(u8){ const bits=[]; for(const b of u8) for(let i=7;i>=0;i--) bits.push((b>>i)&1); return bits; }
function bitsToGroups(bits, g=11){ const out=[]; for(let i=0;i<bits.length;i+=g){ let v=0; for(let j=0;j<g;j++) v=(v<<1)|(bits[i+j]||0); out.push(v);} return out; }
async function genMnemonic(entBits=128){
  await loadWordlistOnce();
  const ENT=entBits, CS=ENT/32;
  const ent=new Uint8Array(ENT/8); crypto.getRandomValues(ent);
  const hash=await wc_sha256(ent);
  const all=bytesToBits(ent).concat(bytesToBits(hash).slice(0,CS));
  return bitsToGroups(all,11).map(i=>WORDS[i]).join(' ');
}
async function mnemonicToSeed(mnemonic, pass=''){
  const salt = te.encode('mnemonic'+pass).buffer;
  const pwd  = te.encode(mnemonic).buffer;
  return pbkdf2_sha512(new Uint8Array(pwd), new Uint8Array(salt), 2048, 64);
}

/* BIP32 通用（版本可参数化） */
function ser32(i){ const b=new Uint8Array(4); b[0]=(i>>>24)&255;b[1]=(i>>>16)&255;b[2]=(i>>>8)&255;b[3]=i&255; return b; }
function concatBytes(...arrs){ let len=0; for(const a of arrs) len+=a.length; const out=new Uint8Array(len); let off=0; for(const a of arrs){ out.set(a,off); off+=a.length } return out; }

async function serializeXPRV(key, chain, depth, parentFP, child, ver){
  const payload = concatBytes(ver, new Uint8Array([depth&255]), parentFP, ser32(child), chain, new Uint8Array([0]), key);
  const s1 = await wc_sha256(payload), s2 = await wc_sha256(s1);
  const chk = s2.slice(0,4);
  return b58encode(concatBytes(payload, chk));
}
async function serializeXPUB(pub, chain, depth, parentFP, child, ver){
  const payload = concatBytes(ver, new Uint8Array([depth&255]), parentFP, ser32(child), chain, pub);
  const s1 = await wc_sha256(payload), s2 = await wc_sha256(s1);
  const chk = s2.slice(0,4);
  return b58encode(concatBytes(payload, chk));
}

async function bip32RootFromSeed(seed){
  const I = await hmacSHA512(te.encode('Bitcoin seed'), seed);
  const IL = I.slice(0,32), IR = I.slice(32);
  const k = BigInt('0x'+bytesToHex(IL));
  if (k===0n || k>=curveN) throw new Error('Invalid master key');
  const key=IL, chain=IR, depth=0, child=0, parentFP=new Uint8Array([0,0,0,0]);
  const pub = secp.getPublicKey(key, true);
  return { key, chain, pub, depth, child, parentFP };
}
async function CKDpriv(node, index, hardened){
  const idx = hardened ? (index|0x80000000) : index;
  const data = hardened
      ? concatBytes(new Uint8Array([0]), node.key, ser32(idx))
      : concatBytes(secp.getPublicKey(node.key, true), ser32(idx));
  const I = await hmacSHA512(node.chain, data);
  const IL = I.slice(0,32), IR = I.slice(32);
  const ki = (BigInt('0x'+bytesToHex(IL)) + BigInt('0x'+bytesToHex(node.key))) % curveN;
  if (ki===0n) throw new Error('Invalid child key');
  const key = hexToBytes(ki.toString(16).padStart(64,'0'));
  const chain = IR, depth=node.depth+1;
  const parentFP = (await wc_sha256(secp.getPublicKey(node.key,true))).slice(0,4); // 简单 FP（对结果无影响）
  const pub = secp.getPublicKey(key,true);
  return { key, chain, pub, depth, child: idx, parentFP };
}

/* 各链路径 & 账户版本号 */
const VERS = {
  xprv:  new Uint8Array([0x04,0x88,0xAD,0xE4]),
  xpub:  new Uint8Array([0x04,0x88,0xB2,0x1E]),
  zprv:  new Uint8Array([0x04,0xB2,0x43,0x0C]),
  zpub:  new Uint8Array([0x04,0xB2,0x47,0x46]),
};
const PATHS = {
  btc:  ["84'", "0'", "0'", "0"],          // BIP84 账户/外部
  eth:  ["44'", "60'", "0'", "0"],
  tron: ["44'", "195'", "0'", "0"],
  eos:  ["44'", "194'", "0'", "0"],
};

/* 地址编码 */
async function btcBech32FromPub(pubComp){
  const h160 = ripemd160(await wc_sha256(pubComp));
  const prog = Array.from(h160);
  const data = [0 /*v0*/].concat(convertbits(prog,8,5,true));
  return bech32_encode('bc', data);
}
function ethAddressFromPub(pubUncomp){
  const no04 = pubUncomp.slice(1);
  const hash = keccak_256(no04);
  const addr = hash.slice(12); // 20 bytes
  // EIP-55
  const lower = bytesToHex(addr);
  const h = keccak_256(new TextEncoder().encode(lower));
  let out='0x';
  for(let i=0;i<40;i++){
    const ch = lower[i];
    out += parseInt(h[i],16) >= 8 ? ch.toUpperCase() : ch;
  }
  return out;
}
async function tronAddressFromPub(pubUncomp){
  const no04 = pubUncomp.slice(1);
  const hash = keccak_256(no04);
  const body = new Uint8Array([0x41, ...hash.slice(12)]);
  return b58check(body);
}
function eosLegacyFromPub(pubComp){
  // checksum = RIPEMD160(pub + "K1") 前 4 字节
  const suffix = new TextEncoder().encode("K1");
  const csum = ripemd160(new Uint8Array([...pubComp, ...suffix])).slice(0,4);
  return 'EOS'+b58encode(new Uint8Array([...pubComp, ...csum]));
}

/* ===== 绑定 UI ===== */
let gSeed=null, gRoot=null, gMnemonic='';
const tip = (el,msg,cls='muted')=>{ el.className=cls; el.textContent=msg; };

document.addEventListener('DOMContentLoaded', async ()=>{
  try{
    await loadWordlistOnce(); // 静默加载词表并校验
    $('btn-gen').disabled=false;
  }catch(e){
    alert('词表校验失败：'+(e?.message||e));
  }
});

$('btn-gen').onclick = async ()=>{
  const t = $('mn-tip');
  try{
    const ent = parseInt(($('sl-words').value||'128'),10);
    const pass = ($('in-pass').value||'').normalize('NFKD');
    const mnemonic = await genMnemonic(ent);
    const seed = await mnemonicToSeed(mnemonic, pass);

    gMnemonic = mnemonic;
    gSeed = seed;
    gRoot = await bip32RootFromSeed(seed);

    $('out-mnemonic').textContent = mnemonic;
    $('out-seed').textContent = bytesToHex(seed);
    $('mnemo-box').style.display='block';

    $('sl-chain').disabled=false;
    $('btn-derive').disabled=false;
    tip(t,'已生成。接着在下方选择链并导出。','ok');
  }catch(e){
    tip(t,'失败：'+(e?.message||e),'err');
    console.error(e);
  }
};

$('btn-derive').onclick = async ()=>{
  const t = $('drv-tip');
  try{
    if(!gRoot) throw new Error('请先生成助记词/Seed');

    const chain = $('sl-chain').value;
    const index = Math.max(0, parseInt(($('in-index').value||'0'),10));
    $('out-idx').textContent = index;

    // 走路径（账户层）
    let node = gRoot;
    const path = PATHS[chain];
    for(let i=0;i<path.length;i++){
      const seg = path[i];
      const hard = seg.endsWith("'");
      const val  = parseInt(seg.replace("'",""),10);
      node = await CKDpriv(node, val, hard);
    }
    // account xprv/xpub（BTC 用 z* 版本，其它用 x*）
    const useZ = (chain==='btc');
    const vprv = useZ ? VERS.zprv : VERS.xprv;
    const vpub = useZ ? VERS.zpub : VERS.xpub;
    const xprv = await serializeXPRV(node.key, node.chain, node.depth, node.parentFP, node.child, vprv);
    const xpub = await serializeXPUB(secp.getPublicKey(node.key,true), node.chain, node.depth, node.parentFP, node.child, vpub);

    // 派生 第 index 个地址（外部链已在路径里是 /0，所以这里再 /index）
    let addrNode = await CKDpriv(node, index, false);
    const priv = addrNode.key;
    const pubC = secp.getPublicKey(priv, true);
    const pubU = secp.getPublicKey(priv, false);

    let address='', pathTitle='';
    if (chain==='btc'){
      pathTitle = "BTC · 路径 m/84'/0'/0'/0/"+index+" · bech32";
      address = await btcBech32FromPub(pubC);
    } else if (chain==='eth'){
      pathTitle = "ETH · 路径 m/44'/60'/0'/0/"+index;
      address = ethAddressFromPub(pubU);
    } else if (chain==='tron'){
      pathTitle = "TRON · 路径 m/44'/195'/0'/0/"+index;
      address = await tronAddressFromPub(pubU);
    } else if (chain==='eos'){
      pathTitle = "EOS · 路径 m/44'/194'/0'/0/"+index+"（legacy 公钥）";
      address = eosLegacyFromPub(pubC);
    }

    $('out-path-title').textContent = pathTitle;
    $('out-xprv').textContent = xprv;
    $('out-xpub').textContent = xpub;
    $('out-addr').textContent = address;
    $('out-box').style.display='block';
    tip(t,'完成。','ok');
  }catch(e){
    tip(t,'失败：'+(e?.message||e),'err');
    console.error(e);
  }
};
</script>
</body>
</html>
