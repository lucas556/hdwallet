<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ETH (m/44'/60'/0'/0) xprv/xpub 推导演示（纯前端）</title>
<style>
  :root{--bg:#0b1220;--card:#0f1724;--line:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--good:#10b981;--bad:#ef4444}
  html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif}
  .wrap{max-width:980px;margin:32px auto;padding:0 16px;overflow-x:hidden}
  h1{margin:0 0 12px}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:18px;margin:14px 0;box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .row{display:flex;flex-wrap:wrap;gap:10px;margin:10px 0;align-items:center}
  .muted{color:var(--muted)}
  input,select,button{background:#0c152a;border:1px solid #243250;color:var(--text);border-radius:10px;padding:10px 12px}
  button{cursor:pointer} button:hover{filter:brightness(1.08)}
  pre{background:#0a1224;border:1px solid #1d2a44;border-radius:10px;padding:12px;max-width:100%;white-space:pre-wrap;word-break:break-all;overflow-wrap:anywhere;overflow:auto}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:1000px){ .grid{grid-template-columns:1fr} }
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .ok{color:var(--good)} .err{color:var(--bad)}
  table{width:100%;border-collapse:collapse}
  th,td{border-top:1px solid #1d2a44;padding:8px 6px;text-align:left;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  th{color:#aab6d1}
</style>
</head>
<body>
<div class="wrap">
  <h1>ETH (m/44'/60'/0'/0) xprv/xpub 推导（BIP39 → BIP32，纯 WebCrypto）</h1>
  <div class="muted">流程：助记词 → Seed → BIP32 Root (m) → m/44'/60'/0'/0 的 xprv/xpub → 从 xpub 派生地址。</div>

  <!-- 步骤 1 已静默：只在校验失败时弹窗。 -->

  <div class="card">
    <h3>2) 生成助记词</h3>
    <div class="row">
      <label>词数：
        <select id="sl-words">
          <option value="128">12 词（128-bit ENT）</option>
          <option value="256">24 词（256-bit ENT）</option>
        </select>
      </label>
      <label>可选 passphrase：
        <input id="in-pass" placeholder="推荐留空（BIP39 passphrase）"/>
      </label>
      <button id="btn-gen" disabled>生成助记词并推导 Seed</button>
      <span id="mn-tip" class="muted"></span>
    </div>
    <div id="mnemo-box" style="display:none">
      <div class="row"><b>助记词：</b></div>
      <pre id="out-mnemonic" class="mono"></pre>
      <div class="row"><b>Seed (64 字节十六进制)：</b></div>
      <pre id="out-seed" class="mono"></pre>
    </div>
  </div>

  <div class="card">
    <h3>3) BIP32 Root (m)</h3>
    <div id="root-box" style="display:none">
      <div class="grid">
        <div>
          <div class="row"><b>Root xprv (m)：</b></div>
          <pre id="out-root-xprv" class="mono"></pre>
        </div>
        <div>
          <div class="row"><b>Root xpub (m)：</b></div>
          <pre id="out-root-xpub" class="mono"></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>4) 派生到 m/44'/60'/0'/0 并生成地址</h3>
    <div class="row">
      <button id="btn-derive" disabled>推导 m/44'/60'/0'/0 的 xprv/xpub</button>
      <span id="drv-tip" class="muted"></span>
    </div>
    <div id="path-box" style="display:none">
      <div class="row"><b>路径：</b> <span class="mono">m/44'/60'/0'/0</span></div>
      <div class="grid">
        <div>
          <div class="row"><b>Account xprv：</b></div>
          <pre id="out-path-xprv" class="mono"></pre>
        </div>
        <div>
          <div class="row"><b>Account xpub：</b></div>
          <pre id="out-path-xpub" class="mono"></pre>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid #1d2a44;margin:16px 0">
      <h4>从 Account xpub 派生 ETH 地址（m/44'/60'/0'/0/<i>i</i>）</h4>
      <div class="row">
        <label>起始索引 <input id="addr-start" type="number" min="0" value="0" style="width:110px"></label>
        <label>数量 <input id="addr-count" type="number" min="1" max="100" value="5" style="width:110px"></label>
        <button id="btn-addr" disabled>派生地址</button>
        <span id="addr-tip" class="muted"></span>
      </div>
      <div id="addr-box" style="display:none">
        <table>
          <thead><tr><th>#</th><th>路径</th><th>ETH 地址（EIP-55）</th></tr></thead>
          <tbody id="addr-tbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script type="module">
import * as secp from 'https://esm.run/@noble/secp256k1@1.7.1';
import { ripemd160 } from 'https://esm.run/@noble/hashes@1.4.0/ripemd160';
import { keccak_256 } from 'https://esm.run/@noble/hashes@1.4.0/sha3';

function bytesToHex(u8){ let s=''; for (let i=0;i<u8.length;i++) s+=u8[i].toString(16).padStart(2,'0'); return s; }
function hexToBytes(hex){ const h=hex.replace(/^0x/i,''); const out=new Uint8Array(h.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(h.slice(i*2,i*2+2),16); return out; }
const te=new TextEncoder(), td=new TextDecoder();
const expectWordlistHash='2f5eed53a4727b4bf8880d8f3f199efc90e58503646d9ff8eff3a2ed3b24dbda';
const curveN=secp.CURVE.n;
const $=id=>document.getElementById(id);

async function wc_sha256(bytes){ const out=await crypto.subtle.digest('SHA-256', bytes instanceof Uint8Array?bytes:new Uint8Array(bytes)); return new Uint8Array(out); }
function concatBytes(...arrs){ let len=0; for(const a of arrs) len+=a.length; const out=new Uint8Array(len); let off=0; for(const a of arrs){ out.set(a,off); off+=a.length; } return out; }
function ser32(i){ const b=new Uint8Array(4); b[0]=(i>>>24)&255;b[1]=(i>>>16)&255;b[2]=(i>>>8)&255;b[3]=i&255; return b; }
async function hash160_async(data){ return ripemd160(await wc_sha256(data)); }
async function base58check_async(payload){ const s2=await wc_sha256(await wc_sha256(payload)); const checksum=s2.slice(0,4); return base58encode(concatBytes(payload,checksum)); }
function base58encode(data){ const ALPH='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'; let x=BigInt('0x'+bytesToHex(data)), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } for(let i=0;i<data.length&&data[i]===0;i++) out='1'+out; return out||'1'; }

async function hmacSHA512(keyBytes,dataBytes){ const key=await crypto.subtle.importKey('raw',keyBytes,{name:'HMAC',hash:'SHA-512'},false,['sign']); return new Uint8Array(await crypto.subtle.sign('HMAC',key,dataBytes)); }
async function pbkdf2_sha512(passwordBytes,saltBytes,iter,dkLen){ const key=await crypto.subtle.importKey('raw',passwordBytes,'PBKDF2',false,['deriveBits']); const bits=await crypto.subtle.deriveBits({name:'PBKDF2',hash:'SHA-512',salt:saltBytes,iterations:iter},key,dkLen*8); return new Uint8Array(bits); }

let WORDS=null;
async function loadWordlistOnce(){
  if(WORDS) return WORDS;
  const res=await fetch('./english.txt');
  const buf=new Uint8Array(await res.arrayBuffer());
  const got=bytesToHex(await wc_sha256(buf));
  if(got!==expectWordlistHash) throw new Error('english.txt 校验失败：SHA-256 不匹配');
  WORDS=td.decode(buf).replace(/\r/g,'').trim().split('\n');
  return WORDS;
}
function bytesToBits(u8){ const bits=[]; for(const b of u8) for(let i=7;i>=0;i--) bits.push((b>>i)&1); return bits; }
function bitsToIndices(bits,group=11){ const out=[]; for(let i=0;i<bits.length;i+=group){ let v=0; for(let j=0;j<group;j++) v=(v<<1)|(bits[i+j]||0); out.push(v); } return out; }
async function genMnemonic(entBits=128){ if(!WORDS) await loadWordlistOnce(); const ENT=entBits, CS=ENT/32; const ent=new Uint8Array(ENT/8); crypto.getRandomValues(ent); const hash=await wc_sha256(ent); const all=bytesToBits(ent).concat(bytesToBits(hash).slice(0,CS)); return bitsToIndices(all,11).map(i=>WORDS[i]).join(' '); }
async function mnemonicToSeed(mnemonic, pass){ const salt=te.encode('mnemonic'+(pass||'')).buffer; const pwd=te.encode(mnemonic).buffer; return pbkdf2_sha512(new Uint8Array(pwd), new Uint8Array(salt), 2048, 64); }

async function serializeXPUB_async(pub,chain,depth,parentFP,child){ const ver=new Uint8Array([0x04,0x88,0xB2,0x1E]); return base58check_async(concatBytes(ver,new Uint8Array([depth&255]),parentFP,ser32(child),chain,pub)); }
async function serializeXPRV_async(key,chain,depth,parentFP,child){ const ver=new Uint8Array([0x04,0x88,0xAD,0xE4]); return base58check_async(concatBytes(ver,new Uint8Array([depth&255]),parentFP,ser32(child),chain,new Uint8Array([0]),key)); }

async function bip32RootFromSeed(seed){
  const I=await hmacSHA512(te.encode('Bitcoin seed'),seed);
  const IL=I.slice(0,32), IR=I.slice(32);
  const k=BigInt('0x'+bytesToHex(IL));
  if(k===0n||k>=curveN) throw new Error('Invalid master key');
  const key32=IL, chain=IR, depth=0, child=0, parentFP=new Uint8Array([0,0,0,0]);
  const pub=secp.getPublicKey(key32,true);
  return { key:key32, chain, pub, depth, child, parentFP,
           xprv:await serializeXPRV_async(key32,chain,depth,parentFP,child),
           xpub:await serializeXPUB_async(pub,chain,depth,parentFP,child) };
}
async function CKDpriv(node,index,hardened){
  const {key,chain,depth,pub}=node;
  const idx=hardened?(index|0x80000000):index;
  const data=hardened?concatBytes(new Uint8Array([0]),key,ser32(idx))
                     :concatBytes(secp.getPublicKey(key,true),ser32(idx));
  const I=await hmacSHA512(chain,data); const IL=I.slice(0,32), IR=I.slice(32);
  const ki=(BigInt('0x'+bytesToHex(IL))+BigInt('0x'+bytesToHex(key)))%curveN;
  if(ki===0n) throw new Error('Invalid child key');
  const keyChild=hexToBytes(ki.toString(16).padStart(64,'0'));
  const parentFP=(await hash160_async(pub)).slice(0,4);
  const pubChild=secp.getPublicKey(keyChild,true);
  const depthChild=depth+1;
  return { key:keyChild, chain:IR, pub:pubChild, depth:depthChild, child:idx, parentFP,
           xprv:await serializeXPRV_async(keyChild,IR,depthChild,parentFP,idx),
           xpub:await serializeXPUB_async(pubChild,IR,depthChild,parentFP,idx) };
}
async function CKDpub(node,index){
  const I=await hmacSHA512(node.chain, concatBytes(node.pub, ser32(index)));
  const IL=I.slice(0,32), IR=I.slice(32);
  const childPoint=secp.Point.fromHex(node.pub).add(secp.Point.fromPrivateKey(IL));
  return { pub: childPoint.toRawBytes(true), chain: IR, depth: node.depth+1, child:index };
}
function pubkeyToEthAddress(pubCompressed){
  const uncompressed=secp.Point.fromHex(pubCompressed).toRawBytes(false).slice(1);
  const h=keccak_256(uncompressed); const lower=bytesToHex(h.slice(-20));
  const hash=bytesToHex(keccak_256(new TextEncoder().encode(lower)));
  let out='0x'; for(let i=0;i<lower.length;i++) out += parseInt(hash[i],16)>=8 ? lower[i].toUpperCase() : lower[i];
  return out;
}

/* 全局状态 */
let gSeed=null, gRoot=null, gAccountNode=null;

/* —— 静默加载词表 —— */
document.addEventListener('DOMContentLoaded', async ()=>{
  try{
    await loadWordlistOnce();
    $('btn-gen').disabled=false;
  }catch(e){
    $('btn-gen').disabled=true;
    alert('english.txt 加载/校验失败：'+(e?.message||e));
  }
});

/* 生成助记词 & Seed */
$('btn-gen').onclick = async ()=>{
  const tip=$('mn-tip');
  try{
    const ent=parseInt(($('sl-words').value||'128'),10);
    const pass=($('in-pass').value||'').normalize('NFKD');
    const mnemonic=await genMnemonic(ent);
    const seed=await mnemonicToSeed(mnemonic,pass);
    gSeed=seed;
    $('out-mnemonic').textContent=mnemonic;
    $('out-seed').textContent=bytesToHex(seed);
    $('mnemo-box').style.display='block';

    gRoot=await bip32RootFromSeed(seed);
    $('out-root-xprv').textContent=gRoot.xprv;
    $('out-root-xpub').textContent=gRoot.xpub;
    $('root-box').style.display='block';

    $('drv-tip').textContent='';
    $('btn-derive').disabled=false;
  }catch(e){
    tip.innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>'; console.error(e);
  }
};

/* 推导 account 节点 */
$('btn-derive').onclick = async ()=>{
  const tip=$('drv-tip');
  try{
    if(!gRoot) throw new Error('请先生成 Seed / Root');
    let node=gRoot;
    node=await CKDpriv(node,44,true);
    node=await CKDpriv(node,60,true);
    node=await CKDpriv(node,0,true);
    node=await CKDpriv(node,0,false);
    gAccountNode=node;

    $('out-path-xprv').textContent=node.xprv;
    $('out-path-xpub').textContent=node.xpub;
    $('path-box').style.display='block';
    $('btn-addr').disabled=false;
    tip.textContent='完成。';
  }catch(e){
    tip.innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>'; console.error(e);
  }
};

/* 从 xpub 派生地址 */
$('btn-addr').onclick = async ()=>{
  const tip=$('addr-tip');
  try{
    if(!gAccountNode) throw new Error('请先完成上一步');
    const start=Math.max(0, parseInt(($('addr-start').value||'0'),10));
    const count=Math.min(100, Math.max(1, parseInt(($('addr-count').value||'5'),10)));
    const tbody=$('addr-tbody'); tbody.innerHTML='';
    for(let i=0;i<count;i++){
      const idx=start+i;
      const child=await CKDpub({pub:gAccountNode.pub,chain:gAccountNode.chain,depth:gAccountNode.depth}, idx);
      const addr=pubkeyToEthAddress(child.pub);
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${idx}</td><td class="mono">m/44'/60'/0'/0/${idx}</td><td class="mono">${addr}</td>`;
      tbody.appendChild(tr);
    }
    $('addr-box').style.display='block';
    tip.textContent=`已派生 ${count} 个地址。`;
  }catch(e){
    tip.innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>'; console.error(e);
  }
};
</script>
</body>
</html>
