<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>多链账户与地址推导（BIP39 → BIP32）</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--text:#e5e7eb;--muted:#9ca3af;--good:#10b981;--bad:#ef4444}
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif}
    .wrap{max-width:1100px;margin:28px auto;padding:0 16px;overflow-x:hidden}
    h1{margin:0 0 8px}.muted{color:var(--muted)}
    .card{background:#0f1724;border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:18px;margin:14px 0;box-shadow:0 10px 28px rgba(0,0,0,.35)}
    .row{display:flex;flex-wrap:wrap;gap:10px;margin:10px 0;align-items:center}
    input,select,button{background:#0c152a;border:1px solid #243250;color:var(--text);border-radius:10px;padding:10px 12px}
    button{cursor:pointer} button:hover{filter:brightness(1.08)}
    pre{background:#0a1224;border:1px solid #1d2a44;border-radius:10px;padding:12px;max-width:100%;
        white-space:pre-wrap;word-break:break-all;overflow-wrap:anywhere;overflow:auto}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){ .grid-2{grid-template-columns:1fr} }
  </style>
</head>
<body>
<div class="wrap">
  <h1>多链账户与地址推导（BIP39 → BIP32，纯 WebCrypto）</h1>
  <div class="muted">选择目标链后，一键生成该链的账户级扩展键与指定 index 的地址（或 EOS 公钥）。</div>

  <!-- 词表校验仅在失败时显示 -->
  <div class="card" id="wl-card" style="display:none">
    <h3>词表校验</h3>
    <div class="row"><span id="wl-tip" class="muted"></span></div>
  </div>

  <div class="card">
    <h3>① 生成助记词 &amp; Seed</h3>
    <div class="row">
      <label>词数：
        <select id="sl-words">
          <option value="128">12 词（128-bit）</option>
          <option value="256">24 词（256-bit）</option>
        </select>
      </label>
      <label>可选 passphrase：
        <input id="in-pass" type="password" autocomplete="new-password" spellcheck="false" placeholder="推荐留空（BIP39 passphrase）"/>
      </label>
      <button id="btn-gen" disabled>生成助记词并推导 Seed &amp; Root</button>
      <button id="btn-lock" title="清除敏感数据并锁屏">清除/锁屏</button>
      <span id="mn-tip" class="muted"></span>
    </div>
    <div id="mnemo-box" style="display:none">
      <div class="row"><b>助记词：</b></div><pre id="out-mnemonic" class="mono"></pre>
      <div class="row"><b>Seed (64B hex)：</b></div><pre id="out-seed" class="mono"></pre>
    </div>
    <div id="root-box" class="grid-2" style="display:none">
      <div><div class="row"><b>Root xprv (m)：</b></div><pre id="out-root-xprv" class="mono"></pre></div>
      <div><div class="row"><b>Root xpub (m)：</b></div><pre id="out-root-xpub" class="mono"></pre></div>
    </div>
  </div>

  <div class="card">
    <h3>② 选择链并生成账户 + 地址</h3>
    <div class="row">
      <label>目标链：
        <select id="sl-chain">
          <option value="BTC">BTC（BIP84，zprv/zpub，地址 bc1q）</option>
          <option value="ETH">ETH（m/44'/60'/0'/0，EIP-55）</option>
          <option value="TRX">TRON（m/44'/195'/0'/0，Base58Check）</option>
          <option value="EOS">EOS（m/44'/194'/0'/0，EOS Legacy + PUB_K1_）</option>
        </select>
      </label>
      <label>索引：
        <input id="in-index" type="number" inputmode="numeric" min="0" step="1" value="0" style="width:110px" onwheel="this.blur()"/>
      </label>
      <button id="btn-derive-chain">生成</button>
      <span id="ch-tip" class="muted"></span>
    </div>

    <div id="acct-box" style="display:none">
      <div class="row" id="acct-path-line"></div>
      <div class="grid-2">
        <div><div class="row"><b id="lbl-xprv">BIP32 Extended Private Key：</b></div><pre id="out-xprv" class="mono"></pre></div>
        <div><div class="row"><b id="lbl-xpub">BIP32 Extended Public Key：</b></div><pre id="out-xpub" class="mono"></pre></div>
      </div>
      <div class="row" id="addr-title"></div><pre id="out-addr" class="mono"></pre>
      <div id="eos-k1-box" style="display:none;margin-top:8px;">
        <div class="row"><b>K1 公钥（PUB_K1_…）：</b></div>
        <pre id="out-eos-k1" class="mono"></pre>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ── 依赖 ── */
import * as noble from './vendor/noble.bundle.js';
const { secp, keccak_256, rmd160 } = noble;

/* ── 常量配置（统一魔法数） ── */
const CONFIG = {
  WORDLIST_SHA256: '2f5eed53a4727b4bf8880d8f3f199efc90e58503646d9ff8eff3a2ed3b24dbda',
  BTC: {
    HRP: 'bc',
    PURPOSE: 84, COIN: 0, ACCOUNT: 0, CHANGE: 0,
    SLIP132: {
      ZPRV: [0x04,0xB2,0x43,0x0C],
      ZPUB: [0x04,0xB2,0x47,0x46],
    }
  },
  ETH: { PURPOSE: 44, COIN: 60,  ACCOUNT: 0, CHANGE: 0 },
  TRX: { PURPOSE: 44, COIN: 195, ACCOUNT: 0, CHANGE: 0, PFX: 0x41 },
  EOS: { PURPOSE: 44, COIN: 194, ACCOUNT: 0, CHANGE: 0 },
};

/* ── 基础工具 ── */
const te=new TextEncoder(), td=new TextDecoder();
const $=id=>document.getElementById(id);
const curveN=secp.CURVE.n;

const b2h=u8=>Array.from(u8).map(x=>x.toString(16).padStart(2,'0')).join('');
const cat=(...arrs)=>{let len=0;for(const a of arrs)len+=a.length;const out=new Uint8Array(len);let o=0;for(const a of arrs){out.set(a,o);o+=a.length;}return out;}
const ser32=i=>new Uint8Array([i>>>24,i>>>16,i>>>8,i&255]);
async function sha256(u8){return new Uint8Array(await crypto.subtle.digest('SHA-256',u8));}
async function hash160(u8){return rmd160.ripemd160(await sha256(u8));}
async function hmac512(key,data){const k=await crypto.subtle.importKey('raw',key,{name:'HMAC',hash:'SHA-512'},false,['sign']);return new Uint8Array(await crypto.subtle.sign('HMAC',k,data));}
async function pbkdf2_sha512(pwd,salt,iters,dkLen){const k=await crypto.subtle.importKey('raw',pwd,'PBKDF2',false,['deriveBits']);const bits=await crypto.subtle.deriveBits({name:'PBKDF2',hash:'SHA-512',salt,iterations:iters},k,dkLen*8);return new Uint8Array(bits);}

/* Base58/Bech32 */
function b58(data){
  const A='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  let x = data.reduce((n,b)=> (n<<8n) + BigInt(b), 0n);
  const out = [];
  while(x>0n){ out.push(A[Number(x%58n)]); x/=58n; }
  for(let i=0;i<data.length && data[i]===0;i++) out.push('1');
  return out.length ? out.reverse().join('') : '1';
}
async function b58check(payload){
  const d1 = await sha256(payload);
  const d2 = await sha256(d1);
  return b58(cat(payload, d2.slice(0,4)));
}
const BCH='qpzry9x8gf2tvdw0s3jn54khce6mua7l';
function b32_polymod(v){const G=[0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];let c=1;for(const x of v){const b=c>>25;c=(c&0x1ffffff)<<5^x;for(let i=0;i<5;i++)if((b>>i)&1)c^=G[i];}return c>>>0;}
function b32_hrp(h){const a=[];for(let i=0;i<h.length;i++)a.push(h.charCodeAt(i)>>5);a.push(0);for(let i=0;i<h.length;i++)a.push(h.charCodeAt(i)&31);return a;}
function b32_convert(data,from,to,pad=true){let acc=0,bits=0,ret=[],maxv=(1<<to)-1,maxAcc=(1<<(from+to-1))-1;for(const v of data){if(v<0||(v>>from))return null;acc=((acc<<from)|v)&maxAcc;bits+=from;while(bits>=to){bits-=to;ret.push((acc>>bits)&maxv);}}if(pad){if(bits)ret.push((acc<<(to-bits))&maxv);}else if(bits>=from||((acc<<(to-bits))&maxv))return null;return ret;}
function b32_encode(hrp,data){const chk=b32_polymod(b32_hrp(hrp).concat(data).concat([0,0,0,0,0,0]))^1;const cs=[];for(let p=0;p<6;p++)cs.push((chk>>5*(5-p))&31);const all=data.concat(cs);return hrp+'1'+all.map(x=>BCH[x]).join('');}
async function btc_p2wpkh(pub){
  const h160=await hash160(pub);
  const conv = b32_convert([...h160],8,5,true);
  if (!conv) throw new Error('bech32 convert failed');
  const data=[0].concat(conv);
  return b32_encode(CONFIG.BTC.HRP, data);
}

/* BIP39 */
let WORDS=null;
async function loadWords() {
  if (WORDS) return WORDS;
  const res=await fetch('./english.txt'); const buf=new Uint8Array(await res.arrayBuffer());
  const ok=b2h(await sha256(buf))===CONFIG.WORDLIST_SHA256;
  if(!ok){
    $('wl-card').style.display='block';
    $('wl-tip').innerHTML='<span class="err">english.txt 校验失败（SHA-256 不匹配）</span>';
    throw new Error('wordlist hash mismatch');
  }
  WORDS=td.decode(buf).replace(/\r/g,'').trim().split('\n');
  if (WORDS.length !== 2048) {
    $('wl-card').style.display='block';
    $('wl-tip').innerHTML='<span class="err">english.txt 词数应为 2048，实际为 '+WORDS.length+'</span>';
    throw new Error('wordlist size mismatch');
  }
  return WORDS;
}
const bytes2bits=u8=>{const out=[];for(const b of u8)for(let i=7;i>=0;i--)out.push((b>>i)&1);return out;}
const bits2idx=(bits,g=11)=>{const out=[];for(let i=0;i<bits.length;i+=g){let v=0;for(let j=0;j<g;j++)v=(v<<1)|(bits[i+j]||0);out.push(v);}return out;}
async function genMnemonic(entBits=128){
  await loadWords(); const ENT=entBits,CS=ENT/32;
  const ent=new Uint8Array(ENT/8); crypto.getRandomValues(ent);
  const cs=bytes2bits(await sha256(ent)).slice(0,CS);
  return bits2idx(bytes2bits(ent).concat(cs),11).map(i=>WORDS[i]).join(' ');
}
// NFKD 规整
function normNFKD(s){ return (s ?? '').normalize('NFKD'); }
function normMnemonicString(s){ return normNFKD(String(s).trim().replace(/\s+/g, ' ')); }
async function mnemonicToSeed(mn, pass){
  const mnN = normMnemonicString(mn);
  const pwN = normNFKD(pass);
  return pbkdf2_sha512(te.encode(mnN), te.encode('mnemonic'+pwN), 2048, 64);
}

// BigInt <-> bytes
const bytesToBig = (u)=> u.reduce((n,b)=>(n<<8n)+BigInt(b), 0n);
const bigToBytes = (n, len=32)=>{ const o=new Uint8Array(len); for(let i=len-1;i>=0;i--){ o[i]=Number(n&255n); n>>=8n; } return o; };

/* BIP32 */
async function rootFromSeed(seed){
  const I=await hmac512(te.encode('Bitcoin seed'),seed); const IL=I.slice(0,32),IR=I.slice(32);
  const k = bytesToBig(IL); if(k===0n||k>=curveN) throw new Error('invalid master');
  const pub=secp.getPublicKey(IL,true); return {key:IL,chain:IR,pub,depth:0,child:0,parentFP:new Uint8Array(4)};
}
async function ckdPriv(n,i,hard){
  const idx = hard ? (i|0x80000000) : i;
  const data= hard ? cat(new Uint8Array([0]), n.key, ser32(idx))
                   : cat(n.pub, ser32(idx));
  const I  = await hmac512(n.chain, data);
  const IL = I.slice(0,32), IR = I.slice(32);
  const ki = (bytesToBig(IL) + bytesToBig(n.key)) % curveN;
  if (ki === 0n) throw new Error('invalid child');
  const key = bigToBytes(ki, 32);
  const pub = secp.getPublicKey(key, true);
  const fp  = (await hash160(n.pub)).slice(0,4);
  return { key, chain: IR, pub, depth: n.depth+1, child: idx, parentFP: fp };
}
async function ckdPub(pub, chain, depth, i){
  const I  = await hmac512(chain, cat(pub, ser32(i)));
  const il = bytesToBig(I.slice(0,32));
  if (il >= curveN) throw new Error('invalid IL');
  const child = secp.Point.fromHex(pub).add(secp.Point.BASE.multiply(il)).toRawBytes(true);
  const fp = (await hash160(pub)).slice(0,4); // 父指纹来自父公钥
  return { pub: child, chain: I.slice(32), depth: depth+1, parentFP: fp, child: i };
}
async function serXPRV(key,chain,depth,fp,child,ver=[0x04,0x88,0xAD,0xE4]){return b58check(cat(new Uint8Array(ver),new Uint8Array([depth]),fp,ser32(child),chain,new Uint8Array([0]),key));}
async function serXPUB(pub,chain,depth,fp,child,ver=[0x04,0x88,0xB2,0x1E]){return b58check(cat(new Uint8Array(ver),new Uint8Array([depth]),fp,ser32(child),chain,pub));}

function lockBtn(btn, on){ if(!btn) return; btn.disabled = !!on; btn.dataset.lock = on ? '1' : '0'; }
function isLocked(btn){ return btn?.dataset.lock === '1'; }

/* 各链地址 */
function ethFromPub(pub){const un=secp.Point.fromHex(pub).toRawBytes(false).slice(1); const h=keccak_256(un).slice(12);
  const lower=b2h(h).toLowerCase(); const hh=b2h(keccak_256(te.encode(lower))); let out='0x';
  for(let i=0;i<lower.length;i++) out+=(parseInt(hh[i],16)>=8)?lower[i].toUpperCase():lower[i]; return out;}
async function tronFromPub(pub){const un=secp.Point.fromHex(pub).toRawBytes(false).slice(1);const a=keccak_256(un).slice(12);return b58check(cat(new Uint8Array([CONFIG.TRX.PFX]),a));}
async function eosLegacy(pub){const c=(rmd160.ripemd160(pub)).slice(0,4);return 'EOS'+b58(cat(pub,c));}
function eosK1(pub){const c=(rmd160.ripemd160(cat(pub,te.encode('K1')))).slice(0,4);return 'PUB_K1_'+b58(cat(pub,c));}

/* 全局 */
let gRoot=null;

/* 工具：读取并校验 index（0 <= idx < 2^31） */
function readIndex(){
  const raw = String(($('in-index')?.value ?? '')).trim();
  const n = Number.parseInt(raw, 10);
  if(!Number.isFinite(n) || n < 0 || n >= 0x80000000){
    alert('索引必须是 0 ~ 2147483647 的整数');
    $('in-index')?.focus();
    throw new Error('invalid index');
  }
  return n;
}

/* 清除/锁屏：擦除敏感内存并清空界面 */
function wipeSensitive(){
  try{
    if (gRoot) {
      if (gRoot.key?.fill)   gRoot.key.fill(0);
      if (gRoot.chain?.fill) gRoot.chain.fill(0);
    }
  }catch(_){}
  gRoot = null;
  // 清空展示
  ['out-mnemonic','out-seed','out-root-xprv','out-root-xpub',
   'out-xprv','out-xpub','out-addr','out-eos-k1'].forEach(id=>{
     const el=$(id); if(el) el.textContent='';
  });
  // 折叠卡片 & 提示
  ['mnemo-box','root-box','acct-box','eos-k1-box'].forEach(id=>{
    const el=$(id); if(el) el.style.display='none';
  });
  $('ch-tip').textContent = '已锁定，需重新生成。';
}

/* 事件绑定 */
document.addEventListener('DOMContentLoaded', async ()=>{
  // 防滚轮误改 index（双保险，除 onwheel 外再阻止默认）
  const idxEl = $('in-index');
  if (idxEl){
    idxEl.addEventListener('wheel', (e)=>{ e.preventDefault(); idxEl.blur(); }, {passive:false});
  }

  if (!isSecureContext) {
    $('mn-tip').innerHTML = '<span class="err">请在 https 或 localhost 下使用（随机数与 WebCrypto 需要安全上下文）。</span>';
    $('btn-gen').disabled = true;
  }
  try {
    await loadWords();
    if (isSecureContext) $('btn-gen').disabled=false;
  } catch(e){
    $('btn-gen').disabled = true;
    $('mn-tip').innerHTML = '<span class="err">词表加载失败（离线/损坏），无法生成助记词。</span>';
    console.error(e);
  }

  // 网络状态提示（可选）
  window.addEventListener('offline', ()=>{$('mn-tip').innerHTML='<span class="err">已离线：若未缓存词表，将无法生成助记词。</span>';});
  window.addEventListener('online',  ()=>{$('mn-tip').textContent='';});

  // 清除/锁屏按钮
  $('btn-lock').addEventListener('click', ()=> wipeSensitive());

  // 页面隐藏/卸载时清理
  document.addEventListener('visibilitychange', ()=>{ if (document.hidden) wipeSensitive(); });
  window.addEventListener('pagehide', ()=> wipeSensitive());

  $('btn-gen').addEventListener('click', async ()=>{
    const btn=$('btn-gen'); if(isLocked(btn)) return; lockBtn(btn,true);
    const tip=$('mn-tip');
    try{
      const ent = parseInt(($('sl-words').value||'128'),10);
      const pass = ($('in-pass').value || '');
      const mnemonic = await genMnemonic(ent);
      const seed     = await mnemonicToSeed(mnemonic, pass);
      gRoot          = await rootFromSeed(seed);

      $('out-mnemonic').textContent = mnemonic;
      $('out-seed').textContent     = b2h(seed);
      $('mnemo-box').style.display  = 'block';

      const rx = await serXPRV(gRoot.key, gRoot.chain, gRoot.depth, gRoot.parentFP, gRoot.child);
      const ru = await serXPUB(gRoot.pub, gRoot.chain, gRoot.depth, gRoot.parentFP, gRoot.child);
      $('out-root-xprv').textContent = rx;
      $('out-root-xpub').textContent = ru;
      $('root-box').style.display = 'block';

      $('ch-tip').textContent = '就绪';
    }catch(e){
      tip.innerHTML = '<span class="err">失败：'+(e?.message||e)+'</span>';
      console.error(e);
    }finally{
      lockBtn(btn,false);
    }
  });

  $('btn-derive-chain').addEventListener('click', async ()=>{
    const btn=$('btn-derive-chain'); if(isLocked(btn)) return;

    // 先检查是否已生成 seed/root；直接弹窗并返回
    if(!gRoot){
      alert('请先执行“① 生成助记词 & Seed”。');
      return;
    }

    lockBtn(btn,true);
    const tip=$('ch-tip'); const chain=$('sl-chain').value;
    const outX=$('out-xprv'), outU=$('out-xpub'), outA=$('out-addr'); const lblX=$('lbl-xprv'), lblU=$('lbl-xpub');

    $('eos-k1-box').style.display='none';
    outX.textContent=outU.textContent=outA.textContent='';
    tip.textContent='';

    try{
      const index = readIndex();
      let n=gRoot, pathText='';

      if (chain === 'BTC') {
        const C = CONFIG.BTC;
        // m/84'/0'/0' 账户
        n = await ckdPriv(n, C.PURPOSE, true);
        n = await ckdPriv(n, C.COIN,    true);
        n = await ckdPriv(n, C.ACCOUNT, true);

        // m/84'/0'/0'/0 作为 BIP32 Extended（zprv/zpub）
        const change0 = await ckdPriv(n, C.CHANGE, false);

        const zprv = await serXPRV(change0.key, change0.chain, change0.depth, change0.parentFP, change0.child, C.SLIP132.ZPRV);
        const zpub = await serXPUB(change0.pub, change0.chain, change0.depth, change0.parentFP, change0.child, C.SLIP132.ZPUB);

        // 地址 m/84'/0'/0'/0/index
        const aN   = await ckdPub(change0.pub, change0.chain, change0.depth, index);
        const addr = await btc_p2wpkh(aN.pub);

        pathText = `m/${C.PURPOSE}'/${C.COIN}'/${C.ACCOUNT}'/${C.CHANGE}；地址：/${index} → bech32`;
        lblX.textContent = 'BIP32 Extended Private Key（zprv）：';
        lblU.textContent = 'BIP32 Extended Public Key（zpub）：';
        outX.textContent = zprv;
        outU.textContent = zpub;
        $('addr-title').textContent = `地址 ${index}（bc1q）：`;
        outA.textContent = addr;

      } else if (chain === 'ETH') {
        const C = CONFIG.ETH;
        n=await ckdPriv(n,C.PURPOSE,true); n=await ckdPriv(n,C.COIN,true); n=await ckdPriv(n,C.ACCOUNT,true); n=await ckdPriv(n,C.CHANGE,false);
        pathText=`m/${C.PURPOSE}'/${C.COIN}'/${C.ACCOUNT}'/${C.CHANGE}；地址 /${index}`;
        const aN = await ckdPub(n.pub,n.chain,n.depth,index);
        const addr = ethFromPub(aN.pub);

        lblX.textContent='BIP32 Extended Private Key：';
        lblU.textContent='BIP32 Extended Public Key：';
        outX.textContent=await serXPRV(n.key,n.chain,n.depth,n.parentFP,n.child);
        outU.textContent=await serXPUB(n.pub,n.chain,n.depth,n.parentFP,n.child);
        $('addr-title').textContent=`地址 ${index}（EIP-55）：`;
        outA.textContent=addr;

      } else if (chain === 'TRX') {
        const C = CONFIG.TRX;
        n=await ckdPriv(n,C.PURPOSE,true); n=await ckdPriv(n,C.COIN,true); n=await ckdPriv(n,C.ACCOUNT,true); n=await ckdPriv(n,C.CHANGE,false);
        pathText=`m/${C.PURPOSE}'/${C.COIN}'/${C.ACCOUNT}'/${C.CHANGE}；地址 /${index}`;
        const aN = await ckdPub(n.pub,n.chain,n.depth,index);
        const addr = await tronFromPub(aN.pub);

        lblX.textContent='BIP32 Extended Private Key：';
        lblU.textContent='BIP32 Extended Public Key：';
        outX.textContent=await serXPRV(n.key,n.chain,n.depth,n.parentFP,n.child);
        outU.textContent=await serXPUB(n.pub,n.chain,n.depth,n.parentFP,n.child);
        $('addr-title').textContent=`地址 ${index}（TRON）：`;
        outA.textContent=addr;

      } else if (chain === 'EOS') {
        const C = CONFIG.EOS;
        n=await ckdPriv(n,C.PURPOSE,true); n=await ckdPriv(n,C.COIN,true); n=await ckdPriv(n,C.ACCOUNT,true); n=await ckdPriv(n,C.CHANGE,false);
        pathText=`m/${C.PURPOSE}'/${C.COIN}'/${C.ACCOUNT}'/${C.CHANGE}；公钥 /${index}`;
        const aN = await ckdPub(n.pub,n.chain,n.depth,index);
        const legacy = await eosLegacy(aN.pub);
        const k1 = eosK1(aN.pub);

        lblX.text内容='BIP32 Extended Private Key：'; // 中文属性可能导致旧浏览器警告，但可正常执行
        lblX.textContent='BIP32 Extended Private Key：';
        lblU.textContent='BIP32 Extended Public Key：';
        outX.textContent=await serXPRV(n.key,n.chain,n.depth,n.parentFP,n.child);
        outU.textContent=await serXPUB(n.pub,n.chain,n.depth,n.parentFP,n.child);
        $('addr-title').textContent=`示例 /${index} 公钥（EOS…）：`;
        outA.textContent=legacy;
        $('eos-k1-box').style.display='block';
        $('out-eos-k1').textContent=k1;
      }

      $('acct-path-line').innerHTML=`<b>路径：</b> <span class="mono">${pathText}</span>`;
      $('acct-box').style.display='block'; tip.textContent='完成';
    }catch(e){
      $('ch-tip').innerHTML='<span class="err">失败：'+(e?.message||e)+'</span>';
      console.error(e);
    }finally{
      lockBtn(btn,false);
    }
  });
});
</script>
</body>
</html>
