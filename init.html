<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词（FIDO2 加密前置）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.03);border-radius:12px;padding:18px;margin-bottom:18px;box-shadow:0 6px 20px rgba(0,0,0,0.45)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0}
    button{background:linear-gradient(180deg,#0f172a,#071226);border:1px solid rgba(255,255,255,0.04);color:var(--text);padding:10px 14px;border-radius:10px;cursor:pointer}
    button[disabled]{opacity:.45;cursor:not-allowed}
    .muted{color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{background:linear-gradient(180deg,#071226,#0b1526);border-radius:10px;padding:10px;display:flex;align-items:center;gap:8px;border:1px dashed rgba(255,255,255,0.03)}
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}
    .word{letter-spacing:.4px}
    .note{font-size:13px;color:var(--muted)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .controls{display:flex;flex-wrap:wrap;gap:8px}
    .small{font-size:13px;color:var(--muted)}
    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（FIDO2 加密优先）</h1>

    <!-- 1. 注册/复用 FIDO2 -->
    <div class="card">
      <h3>步骤 A：注册/复用 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register">1) 注册或选择本域凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="note">必须先有凭证，后续生成的助记词会使用该凭证派生的 KEK 加密保存。</div>
    </div>

    <!-- 2. 生成助记词（在注册后启用） -->
    <div class="card">
      <h3>步骤 B：生成助记词（仅显示一次，支持可选离线备份）</h3>
      <div class="row">
        <label><input id="cb-backup" type="checkbox"> 生成并下载离线备份（如果选中则不显示助记词）</label>
      </div>
      <div class="row">
        <button id="btn-gen" disabled>2) 生成助记词</button>
        <button id="btn-show" disabled>显示助记词（需 FIDO2 解密）</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <div id="mnemo-card" style="display:none; margin-top:10px">
        <div class="grid" id="mnemo-grid"></div>
        <div class="note" style="margin-top:8px">默认遮挡。点击“显示助记词”并完成 FIDO2 授权后会在 30 秒内显示助记词。</div>
      </div>
    </div>

    <!-- 3. 加密分支并写库（保持原先行为） -->
    <div class="card">
      <h3>步骤 C：加密 xprv/xpub 并写入数据库</h3>
      <div class="row">
        <button id="btn-encrypt" disabled>3) 使用凭证加密并写入数据库</button>
        <span id="encrypt-tip" class="muted"></span>
      </div>
      <div class="note">加密后的 bundle 不包含助记词明文。写库失败时会显示错误。</div>
    </div>

    <div id="final" class="small"></div>
  </div>

<script type="module">
/* ---------- 依赖 ---------- */
import {
  ensureCredentialWithChoice,
  deriveKEK,
  deriveKEKWithSalt,
  aesGcmEncryptStr,
  aesGcmDecryptStr,
} from './js/fido2.js';
import {
  genMnemonic, mnemonicToSeed, exportBranches,
  createPasswordBackupBlob, validatePasswordStrict
} from './js/hdwallet-core.js';

/* ---------- 小工具（多候选选择器 + 安全绑定） ---------- */
const $$ = sel => document.querySelector(sel);
const pick = (...ids) => ids.map(id => (typeof id === 'string' ? id : null))
                            .filter(Boolean)
                            .map(s => document.querySelector(s))
                            .find(Boolean) || null;
const on = (el, ev, fn) => el && el.addEventListener(ev, fn, { passive: true });

/* 支持多候选 ID 的“取元素”封装（命名尽量覆盖你之前几版） */
const el = {
  // Step A
  btnCred:  () => pick('#btn-register', '#btn-cred', '#btnFidoRegister'),
  tipCred:  () => pick('#reg-tip', '#tip-cred'),
  // Step B：生成/显示相关
  btnGen:   () => pick('#btn-gen', '#btnGen', '#genMnemonic'),
  tipGen:   () => pick('#gen-tip', '#tip-gen'),
  mnWrap:   () => pick('#mnemo-container', '#mnemoWrap'),
  mnGrid:   () => pick('#mnemo-grid', '#mnemoGrid'),
  // 统一遮罩与按钮（两版命名都兼容）
  mask:     () => pick('#mnemo-mask', '#grid-mask', '#mnMask'),
  btnShow:  () => pick('#mnemo-toggle', '#btn-show', '#btnReveal'),
  tipShow:  () => pick('#reveal-tip', '#revealTip'),
  // 备份（可选，缺就跳过）
  chkBackup:() => pick('#want-backup', '#chk-backup'),
  boxBackup:() => pick('#backup-area', '#backupArea'),
  pw1:      () => pick('#pw1'),
  pw2:      () => pick('#pw2'),
  btnBackup:() => pick('#btn-backup', '#btnBackup'),
  tipPw:    () => pick('#pw-tip', '#tip-pw'),
  // Step 4
  btnEncrypt:() => pick('#btn-encrypt', '#btnEncrypt'),
  tipEncrypt:() => pick('#encrypt-tip', '#tip-encrypt'),
  tipFinal: () => pick('#final-tip', '#tip-final'),
};

/* ---------- 业务状态 ---------- */
const API_BASE = 'https://wallet.lucas-l-shang.workers.dev';
let mnemonic = null;        // 明文助记词（只在生成阶段短暂持有）
let branches = null;        // 各链分支（xprv/xpub 等）
let sealed = null;          // { ctHex, ivHex, saltHex, credId } —— 助记词密文包
let maskTimer = null;
const DISPLAY_MS = 30_000;

/* ---------- 遮罩控制（统一遮挡/显示 30s） ---------- */
function setMask(visible) {
  const m = el.mask();
  const t = el.tipShow();
  if (!m) return;
  m.style.display = visible ? 'flex' : 'none';
  if (t) t.style.display = visible ? 'none' : 'inline';
  if (visible) { clearTimeout(maskTimer); maskTimer = null; }
}

function startCountdown() {
  const t = el.tipShow();
  if (!t) return;
  let left = DISPLAY_MS / 1000;
  t.textContent = `已显示，${left}s 后自动遮挡`;
  clearTimeout(maskTimer);
  maskTimer = setInterval(() => {
    left -= 1;
    if (left <= 0) { setMask(true); clearInterval(maskTimer); return; }
    t.textContent = `已显示，${left}s 后自动遮挡`;
  }, 1000);
}

/* ---------- 助记词渲染 ---------- */
function renderGrid(words) {
  const grid = el.mnGrid();
  const wrap = el.mnWrap();
  if (!grid || !wrap) return;
  grid.innerHTML = '';
  words.forEach((w, i) => {
    const d = document.createElement('div');
    d.className = 'cell';
    d.innerHTML = `<span class="badge">${i + 1}</span><span class="word">${w}</span>`;
    grid.appendChild(d);
  });
  wrap.style.display = 'block';
  setMask(true); // 初始蒙住
}

/* ---------- 事件绑定：DOMContentLoaded 后统一绑定 ---------- */
document.addEventListener('DOMContentLoaded', () => {
  /* Step A：注册/复用 FIDO2 凭证 */
  on(el.btnCred(), 'click', async () => {
    try {
      const res = await ensureCredentialWithChoice();
      if (el.tipCred()) {
        el.tipCred().innerHTML = res?.created
          ? '<span class="ok">已注册新凭证。</span>'
          : `<span class="ok">已可使用凭证（id: ${(res?.id_hex||'').slice(0,16)}…）。</span>`;
      }
    } catch (e) {
      if (el.tipCred()) el.tipCred().innerHTML = `<span class="err">注册/复用失败：${e?.message||e}</span>`;
      console.error(e);
    }
  });

  /* Step B-1：可选备份 UI（存在才绑定） */
  const chk = el.chkBackup();
  if (chk) {
    on(chk, 'change', () => {
      const area = el.boxBackup();
      if (area) area.style.display = chk.checked ? 'block' : 'none';
      const btn = el.btnBackup();
      if (btn) btn.disabled = !chk.checked;
    });
  }
  const pwInput = () => {
    const p1 = el.pw1(), p2 = el.pw2(), tip = el.tipPw(), btn = el.btnBackup();
    if (!p1 || !p2 || !btn || !tip) return;
    const a = p1.value, b = p2.value;
    if (!a && !b) { tip.textContent = ''; btn.disabled = true; return; }
    if (a !== b) { tip.innerHTML = '<span class="err">两次密码不一致</span>'; btn.disabled = true; return; }
    const v = validatePasswordStrict(a);
    if (!v.ok) { tip.innerHTML = `<span class="err">${v.reason}</span>`; btn.disabled = true; return; }
    tip.innerHTML = '<span class="ok">密码强度通过</span>'; btn.disabled = false;
  };
  on(el.pw1(), 'input', pwInput);
  on(el.pw2(), 'input', pwInput);

  on(el.btnBackup(), 'click', async () => {
    try {
      if (!sealed) { alert('请先生成助记词'); return; }
      const tip = el.tipPw();
      const pass = (el.pw1() && el.pw1().value) || '';
      // 这里的“离线备份”是**助记词密文包**的再次口令保护；若你希望备份明文助记词，请改用展示后解密得到的明文
      const blob = new Blob([JSON.stringify({ sealed }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'mnemonic_backup.enc.json'; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 3000);
      if (tip) tip.innerHTML = '<span class="ok">已生成并下载离线备份（密文包）。</span>';
    } catch (e) {
      const tip = el.tipPw(); if (tip) tip.innerHTML = `<span class="err">备份失败：${e?.message||e}</span>`;
      console.error(e);
    }
  });

  /* Step B-2：生成助记词（FIDO2 就绪后才有意义） */
  on(el.btnGen(), 'click', async () => {
    try {
      // 1) 生成助记词
      mnemonic = genMnemonic(128);          // 12 词
      const words = mnemonic.trim().split(/\s+/);

      // 2) 立即用 FIDO2 派生出的 KEK + salt 加密（仅保存密文）
      const { kek, salt, rp_id, info, credential_id, toHex } = await deriveKEK();
      const encObj = await aesGcmEncryptStr(kek, mnemonic);
      sealed = {
        ctHex: encObj.ciphertext,
        ivHex: encObj.nonce,
        saltHex: toHex(salt),
        credId: credential_id,
        rp_id, info,
      };

      // 3) 立刻清理明文助记词（避免长驻）
      try { mnemonic = ''; } catch {}
      // 仍保留各链分支（需要它们用于加密写库）
      const seed = mnemonicToSeed(words.join(' '), ''); // 这里不再依赖 mnemonic 变量
      branches = exportBranches(seed);

      // 4) UI：渲染网格（默认遮挡）；如勾选“备份”，则不立即展示
      renderGrid(words);
      const sTip = el.tipGen();
      if (sTip) sTip.textContent = ''; // 按你要求移除原文案
      // 统一遮罩由 setMask(true) 控制；点击遮罩/按钮再解密显示 30s
    } catch (e) {
      const sTip = el.tipGen(); if (sTip) sTip.innerHTML = `<span class="err">生成失败：${e?.message||e}</span>`;
      console.error(e);
    }
  });

  /* Step B-3：点击遮罩/按钮 → FIDO2 解密明文 → 显示 30s 后回遮挡 */
  const doReveal = async () => {
    try {
      if (!sealed) return;
      // 重新用 salt + 设备 PRF 派生 KEK（需要触摸/人机验证）
      const { kek } = await deriveKEKWithSalt(sealed.saltHex, sealed.credId);
      // 解密密文包得到明文
      const plain = await aesGcmDecryptStr(kek, sealed.ivHex, sealed.ctHex);
      // 将明文写入网格
      const words = plain.trim().split(/\s+/);
      renderGrid(words);
      // 显示 30s
      setMask(false);
      startCountdown();
      // 安全清理变量
      try { for (let i = 0; i < words.length; i++) words[i] = ''; } catch {}
    } catch (e) {
      console.error(e);
      alert('解密失败：' + (e?.message || e));
    }
  };
  on(el.mask(), 'click', doReveal);
  on(el.btnShow(), 'click', doReveal);

  /* Step 4：写库（与前面一致） */
  on(el.btnEncrypt(), 'click', async () => {
    try {
      if (!branches) { alert('请先生成助记词'); return; }
      if (el.tipEncrypt()) el.tipEncrypt().textContent = '请触摸密钥以继续…';

      const { kek, salt, rp_id, info, credential_id, toHex } = await deriveKEK();
      const enc = async s => s ? await aesGcmEncryptStr(kek, s) : null;
      const bundle = {
        KEKInfo: { rp_id, info, salt: toHex(salt), credential_id },
        chains: {
          ETH:  { path: branches.ETH.path,  PubEnc: await enc(branches.ETH.xpub),   PrivEnc: await enc(branches.ETH.xprv) },
          BTC:  { path: branches.BTC.path,  PubEnc: await enc(branches.BTC.xpub_z), PrivEnc: await enc(branches.BTC.xprv_z) },
          EOS:  { path: branches.EOS.path,  PubEnc: await enc(branches.EOS.xpub),   PrivEnc: await enc(branches.EOS.xprv) },
          TRON: { path: branches.TRON.path, PubEnc: await enc(branches.TRON.xpub),  PrivEnc: await enc(branches.TRON.xprv) },
        }
      };

      const res = await fetch(`${API_BASE}/bundles`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ user_id: 'web-ui', note: '初始化保存（UI）', bundle })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data?.ok) throw new Error(data?.error || `HTTP ${res.status}`);

      // 清理敏感引用
      try { mnemonic = ''; } catch {}
      branches.ETH.xprv = branches.EOS.xprv = branches.TRON.xprv = null;
      branches.BTC.xprv_z = null;

      if (el.tipEncrypt()) el.tipEncrypt().textContent = '';
      if (el.tipFinal()) el.tipFinal().innerHTML = `<span class="ok">注册成功！bundle_id=${data.bundle_id}</span>`;
    } catch (e) {
      if (el.tipEncrypt()) el.tipEncrypt().textContent = '';
      if (el.tipFinal()) el.tipFinal().innerHTML = `<span class="err">写入失败：${e?.message||e}</span>`;
      console.error(e);
    }
  });
});
</script>

</body>
</html>
