<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（注册新 FIDO2 凭证）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;--line:#1f2937;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .btn{
      background:linear-gradient(180deg,#0f172a,#091427);
      border:1px solid rgba(255,255,255,0.08);
      color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer
    }
    .btn:hover{filter:brightness(1.06)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* 助记词网格 */
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{
      background:linear-gradient(180deg,#071226,#0b1526);
      border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;
      display:flex;align-items:center;gap:10px;min-height:44px
    }
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    /* 整块遮挡（覆盖在网格上） */
    .mnemo-box{position:relative}
    .mnemo-mask{
      position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);
      border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)
    }
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .mask-btn{
      display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;
      border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;
      box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none
    }
    .hint{text-align:center;color:#9aa4b4}

    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（注册新 FIDO2 凭证 → 生成即加密）</h1>

    <!-- A. 仅注册新凭证 -->
    <div class="card">
      <h3>步骤 A：注册新的本域 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register" class="btn">1) 注册新凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="muted">该步骤会创建“可发现凭证（discoverable）”。后续步骤会<strong>强制绑定同一把凭证</strong>，防止 A 步骤选 A、B 步骤却触摸 B。</div>
    </div>

    <!-- B. 生成 & 展示（生成即加密；默认整块遮挡） -->
    <div class="card">
      <h3>步骤 B：生成助记词（生成即用步骤 A 的凭证加密；默认整块遮挡）</h3>
      <div class="row">
        <button id="btn-gen" class="btn" disabled>2) 生成助记词并加密</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <!-- 助记词卡片：网格 + 整块遮挡 -->
      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 蒙层：默认可见；点击解密显示 60 秒 -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <button class="mask-btn" id="btn-reveal">显示助记词（需 FIDO2 解密）</button>
              <div class="hint" id="mask-hint">默认遮挡。点击上方按钮并完成 FIDO2 验证后，明文显示 60 秒并自动遮挡。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 写库 -->
    <div class="card">
      <h3>步骤 C：写入数据库（再次验证同一把凭证）</h3>
      <div class="row">
        <button id="btn-save" class="btn" disabled>3) 写入数据库</button>
        <span id="save-tip" class="muted"></span>
      </div>
      <div class="muted">仅写入密文，不包含助记词明文。</div>
    </div>
  </div>

<script type="module">
/* ========= 导入（与现有 fido2.js 对齐；不新增导出名） ========= */
import {
  loadCredHex,
  saveCredHex,
  ensureCredentialWithChoice,
} from './js/fido2.js';

/* ========= 你的 Worker API 基址（保持你原来的常量） ========= */
const API_BASE = 'https://wallet.lucas-l-shang.workers.dev';

/* ========= 本会话绑定：后续步骤要强制使用同一把凭证 ========= */
let selectedCredHex = null;
function setSelectedCredHex(hex) {
  selectedCredHex = hex;
  window.__selectedCredHex = hex;          // 提供给步骤 B/C 复用
  const btnGen = document.getElementById('btn-gen');
  if (btnGen) btnGen.disabled = !hex;      // 只有选定了凭证才能进入下一步
}

/* ========= 小工具 ========= */
// 1) 尝试“枚举本域”的 discoverable credential（不传 allowCredentials）
//    - 成功返回十六进制 rawId；失败/无则返回 null
async function discoverExistingCredentialHex() {
  // 先看本地缓存
  const cached = loadCredHex?.();
  if (cached) return cached;

  if (!navigator.credentials?.get) return null;
  try {
    const cred = await navigator.credentials.get({
      publicKey: {
        userVerification: 'preferred',
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        timeout: 60000,
        // 不设置 allowCredentials：让设备自行枚举 discoverable 凭证
      }
    });
    if (cred?.rawId) {
      const buf = new Uint8Array(cred.rawId);
      let hex = ''; for (const x of buf) hex += x.toString(16).padStart(2, '0');
      saveCredHex?.(hex);
      return hex;
    }
  } catch (_) {
    // 用户取消 / 无 discoverable 凭证 → 视为没有
  }
  return null;
}

// 2) 查数据库：这把 credential 是否已有 bundle 记录
async function fetchBundleByCred(credHex) {
  try {
    const res = await fetch(`${API_BASE}/bundles/by-cred/${encodeURIComponent(credHex)}`, { method: 'GET' });
    if (!res.ok) return null;                          // 404/403 等视为无
    const data = await res.json().catch(() => null);
    return (data?.ok && data?.bundle) ? data.bundle : null;
  } catch {
    return null;
  }
}

/* ========= 页面初始：若本地已有缓存的凭证，提示“可用”但不自动跳转 ========= */
document.addEventListener('DOMContentLoaded', () => {
  try {
    const cached = loadCredHex?.();
    if (cached) {
      const tip = document.getElementById('reg-tip');
      if (tip) tip.innerHTML = `<span class="ok">检测到本地凭证缓存（id: ${cached.slice(0,16)}…），可继续。</span>`;
      setSelectedCredHex(cached);
    }
  } catch {}
});

/* ========= 步骤 A：按钮逻辑 ========= */
document.getElementById('btn-register').onclick = async () => {
  const tip = document.getElementById('reg-tip');

  const say = (html) => { if (tip) tip.innerHTML = html; };

  try {
    // 1) 先枚举行内可发现凭证
    const foundHex = await discoverExistingCredentialHex();

    if (foundHex) {
      // 1.1 查库：这把钥匙是否已有记录？
      const existing = await fetchBundleByCred(foundHex);
      if (existing) {
        // 已存在记录 → 直接跳 wallet.html
        say('<span class="ok">检测到已有凭证，且数据库存在记录，正在跳转…</span>');
        location.href = `wallet.html?cred=${encodeURIComponent(foundHex)}`;
        return;
      }

      // 1.2 库中没有记录 → 询问是否沿用本把钥匙进行初始化
      const okUse = confirm(
        `检测到本域凭证：${foundHex.slice(0,16)}…\n数据库未发现记录。\n是否沿用该凭证用于初始化？`
      );
      if (okUse) {
        setSelectedCredHex(foundHex);
        say(`<span class="ok">已选择沿用凭证（id: ${foundHex.slice(0,16)}…）。可进行下一步。</span>`);
        return;
      }
      // 用户不沿用 → 继续走注册流程
    }

    // 2) 无可用凭证或用户不沿用 → 注册/复用（由 ensureCredentialWithChoice 决定新建或复用）
    say('请触摸安全钥匙以注册/选择凭证…');
    const res = await ensureCredentialWithChoice();    // { ok, id_hex, created }
    const hex = res?.id_hex;
    if (!hex) throw new Error('未获得凭证 ID');

    setSelectedCredHex(hex);
    say(res?.created
      ? `<span class="ok">已注册新凭证（id: ${hex.slice(0,16)}…）。可进行下一步。</span>`
      : `<span class="ok">已选择现有凭证（id: ${hex.slice(0,16)}…）。可进行下一步。</span>`
    );
  } catch (e) {
    console.error(e);
    say(`<span class="err">处理失败：${e?.message || e}</span>`);
  }
};
</script>

</body>
</html>
