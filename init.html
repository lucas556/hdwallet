<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（FIDO2 加密 + 整块遮挡 + 长按解锁）</title>
  <style>
    :root{ --bg:#0b1220; --card:#0f1724; --muted:#9ca3af; --text:#e5e7eb; --line:#1f2937; --good:#10b981; --bad:#ef4444; }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0}
    .muted{color:var(--muted)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    button{background:#0f172a;border:1px solid #27324a;color:#e5e7eb;padding:10px 14px;border-radius:12px;cursor:pointer}
    button:hover{filter:brightness(1.06)} button[disabled]{opacity:.45;cursor:not-allowed}

    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{background:linear-gradient(180deg,#071226,#0b1526);border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;display:flex;align-items:center;gap:10px;min-height:44px}
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    .mnemo-box{position:relative}
    .mnemo-mask{position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)}
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .hold-btn{display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none}
    .dot{width:10px;height:10px;border-radius:999px;background:#22d3ee;box-shadow:0 0 0 6px rgba(34,211,238,.15)}
    .progress{height:4px;background:#1f2a44;width:220px;border-radius:99px;overflow:hidden}
    .bar{height:100%;width:0;background:#22d3ee}
    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- A. 凭证 -->
    <div class="card">
      <h3>步骤 A：注册/复用 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register">1) 注册或选择本域凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="muted">生成/解锁都需要该凭证以派生密钥。</div>
    </div>

    <!-- B. 生成（加密后清明文） + 显示（需长按解锁） -->
    <div class="card">
      <h3>步骤 B：生成助记词（生成时即加密；长按 3 秒解锁显示 60 秒）</h3>
      <div class="row">
        <button id="btn-gen" disabled>2) 生成助记词</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 整块遮挡 -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <div class="hold-btn" id="hold-btn"><span class="dot"></span><span id="hold-text">长按 3 秒显示助记词</span></div>
              <div class="progress"><div class="bar" id="hold-bar"></div></div>
              <div class="muted" id="mask-hint">显示后 60 秒自动遮挡并清空明文。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 写库（直接用已加密的分支数据） -->
    <div class="card">
      <h3>步骤 C：写库</h3>
      <div class="row">
        <button id="btn-save" disabled>3) 写入数据库</button>
        <span id="save-tip" class="muted"></span>
      </div>
      <div class="muted">写库直接使用内存中的已加密 xprv/xpub；bundle 不包含助记词明文。</div>
    </div>
  </div>

<script type="module">
import {
  ensureCredentialWithChoice,
  deriveKEK,
  deriveKEKWithSalt,
  aesGcmEncryptStr,
  aesGcmDecryptStr
} from './js/fido2.js';

import { genMnemonic, mnemonicToSeed, exportBranches } from './js/hdwallet-core.js';

/* ====== 配置 ====== */
const API_BASE  = 'https://wallet.lucas-l-shang.workers.dev';
const HOLD_MS   = 3000;     // 长按 3 秒
const REVEAL_MS = 60000;    // 显示 60 秒

/* ====== 状态（仅保留密文与元数据） ====== */
let sealedMnemonic = null;  // { enc:{nonce,ciphertext}, credId, saltHex }
let kekMeta        = null;  // { rp_id, info, credential_id, saltHex }
let encBranches    = null;  // { ETH:{path,PubEnc,PrivEnc}, ... }
let wordCount      = 12;    // 渲染占位

let autoMaskTimer  = null;

/* ====== DOM 助手 ====== */
const $ = id => document.getElementById(id);
function show(el, yes){ if(el) el.style.display = yes ? '' : 'none'; }
function renderMaskedGrid(n){
  const g=$('mnemo-grid'); g.innerHTML='';
  for(let i=1;i<=n;i++){
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML = `<span class="badge">${i}</span><span>•••••</span>`;
    g.appendChild(d);
  }
}
function renderWords(words){
  const g=$('mnemo-grid'); g.innerHTML='';
  words.forEach((w,i)=>{
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML = `<span class="badge">${i+1}</span><span>${w}</span>`;
    g.appendChild(d);
  });
}
function maskNow(msg){
  clearAutoMask();
  renderMaskedGrid(wordCount);
  show($('mnemo-mask'), true);
  if (msg) $('mask-hint').textContent = msg;
}
function clearAutoMask(){ if(autoMaskTimer){ clearTimeout(autoMaskTimer); autoMaskTimer=null; } }

/* ====== A. 注册/复用凭证 ====== */
$('btn-register').onclick = async ()=>{
  const tip=$('reg-tip');
  try{
    const res = await ensureCredentialWithChoice();
    tip.innerHTML = res.created
      ? '<span class="ok">已注册新凭证。</span>'
      : '<span class="ok">已可使用凭证。</span>';
    $('btn-gen').disabled = false;
  }catch(e){
    tip.innerHTML = '<span class="err">失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
};

/* ====== B-1. 生成：派生 KEK → 加密助记词 → 导出分支并立即加密 → 清理明文 ====== */
$('btn-gen').onclick = async ()=>{
  const tip = $('gen-tip');
  try{
    // 1) 用 FIDO2 派生 KEK（随机 salt）
    const { kek, salt, rp_id, info, credential_id, toHex } = await deriveKEK();
    const saltHex = toHex(salt);

    // 2) 生成助记词并立即加密（只保留密文）
    const mnemonic = genMnemonic(128);
    const encM = await aesGcmEncryptStr(kek, mnemonic);

    // 3) 导出分支，并立刻把 xprv/xpub 全部加密（只保留密文），清理明文
    const seed    = mnemonicToSeed(mnemonic, '');
    const br      = exportBranches(seed);
    const encOf   = async s => s ? await aesGcmEncryptStr(kek, s) : null;
    encBranches = {
      ETH:  { path: br.ETH.path,  PubEnc: await encOf(br.ETH.xpub),   PrivEnc: await encOf(br.ETH.xprv) },
      BTC:  { path: br.BTC.path,  PubEnc: await encOf(br.BTC.xpub_z), PrivEnc: await encOf(br.BTC.xprv_z) },
      EOS:  { path: br.EOS.path,  PubEnc: await encOf(br.EOS.xpub),   PrivEnc: await encOf(br.EOS.xprv) },
      TRON: { path: br.TRON.path, PubEnc: await encOf(br.TRON.xpub),  PrivEnc: await encOf(br.TRON.xprv) },
    };
    // 清理分支明文
    br.ETH.xprv = br.EOS.xprv = br.TRON.xprv = null;
    br.BTC.xprv_z = null;
    br.ETH.xpub = br.EOS.xpub = br.TRON.xpub = null;
    br.BTC.xpub_z = null;

    // 4) 保存密钥元数据（写库要用同一 KEK 信息）
    kekMeta = { rp_id, info, credential_id, saltHex };

    // 5) 助记词只保留密文 & 显示遮挡块（不保留明文）
    sealedMnemonic = { enc: encM, credId: credential_id, saltHex };
    wordCount = mnemonic.trim().split(/\s+/).length || 12;
    // 尽量擦明文
    (async()=>{ try{ /* JS 字符串不可变，仅丢弃引用 */ }catch{} })();

    // UI：展示遮挡卡片
    show($('mnemo-card'), true);
    renderMaskedGrid(wordCount);
    show($('mnemo-mask'), true);
    tip.textContent = '已生成并完成加密；长按 3 秒可解锁查看（显示 60 秒）。';
    $('btn-save').disabled = false;
  }catch(e){
    tip.innerHTML = '<span class="err">失败：'+(e?.message||e)+'</span>';
    console.error(e);
  }
};

/* ====== B-2. 长按 3 秒 → FIDO2 解锁助记词（显示 60 秒） ====== */
(function attachHold(){
  const btn = $('hold-btn'), bar=$('hold-bar'), text=$('hold-text');
  if (!btn) return;

  let pressing=false, t0=0, raf=0, tmr=0;
  const start=()=>{
    if(pressing) return;
    pressing=true; t0=performance.now(); bar.style.width='0%';
    const step=()=>{
      if(!pressing) return;
      const p=Math.min(1,(performance.now()-t0)/HOLD_MS);
      bar.style.width=(p*100)+'%';
      if(p>=1){ done(); return; }
      raf=requestAnimationFrame(step);
    };
    raf=requestAnimationFrame(step);
    tmr=setTimeout(done,HOLD_MS);
  };
  const cancel=()=>{
    pressing=false;
    if(raf) cancelAnimationFrame(raf);
    if(tmr) clearTimeout(tmr);
    bar.style.width='0%';
  };

  const done = async ()=>{
    cancel();
    try{
      if (!sealedMnemonic) throw new Error('no encrypted mnemonic in memory');
      clearAutoMask();

      // 用记录的 credId + saltHex 重新派生 KEK 解密助记词
      const { kek } = await deriveKEKWithSalt(sealedMnemonic.credId, sealedMnemonic.saltHex);
      const mnemonic = await aesGcmDecryptStr(kek, sealedMnemonic.enc);

      const words = mnemonic.trim().split(/\s+/);
      renderWords(words);
      show($('mnemo-mask'), false);

      // 60 秒后自动遮挡并清除明文
      autoMaskTimer = setTimeout(()=>{
        maskNow('已自动遮挡。再次查看需再次长按并通过 FIDO2。');
      }, REVEAL_MS);

      // 擦局部副本（字符串不可变，仅丢引用；words 数组置空）
      try{ for(let i=0;i<words.length;i++) words[i]=''; }catch{}
    }catch(e){
      console.error(e);
      text.textContent='解锁失败，请重试';
      setTimeout(()=> text.textContent='长按 3 秒显示助记词', 1500);
    }
  };

  ['mousedown','touchstart'].forEach(ev=>btn.addEventListener(ev,start));
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=>btn.addEventListener(ev,cancel));
})();

/* ====== C. 写库：直接使用 encBranches + kekMeta ====== */
$('btn-save').onclick = async ()=>{
  const tip = $('save-tip');
  try{
    if (!encBranches || !kekMeta) { alert('请先完成生成'); return; }

    const bundle = {
      KEKInfo: {
        rp_id:        kekMeta.rp_id,
        info:         kekMeta.info,
        salt:         kekMeta.saltHex,
        credential_id:kekMeta.credential_id
      },
      chains: encBranches   // 已经是 { path, PubEnc:{nonce,ciphertext}, PrivEnc:{...} }
    };

    const resp = await fetch(`${API_BASE}/bundles`, {
      method:'POST', headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ user_id:'web-ui', note:'init (encrypted-at-generate)', bundle })
    });
    const data = await resp.json().catch(()=> ({}));
    if (!resp.ok || !data?.ok) throw new Error(data?.error || `HTTP ${resp.status}`);
    tip.innerHTML = `<span class="ok">写库成功：bundle_id=${data.bundle_id}</span>`;
  }catch(e){
    tip.innerHTML = `<span class="err">写库失败：${e?.message||e}</span>`;
    console.error(e);
  }
};
</script>
</body>
</html>
