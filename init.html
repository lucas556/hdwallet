<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（FIDO2 加密 + 整块遮挡）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;--line:#1f2937;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0}
    .muted{color:var(--muted)}
    button{
      background:linear-gradient(180deg,#0f172a,#091427);border:1px solid rgba(255,255,255,0.06);
      color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer
    }
    button:hover{filter:brightness(1.06)}
    button[disabled]{opacity:.45;cursor:not-allowed}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .small{font-size:13px;color:var(--muted)}

    /* 输入框（离线备份密码） */
    input[type="password"]{
      background:#0b1324;border:1px solid rgba(255,255,255,.08);
      color:#e5e7eb;border-radius:10px;padding:10px 12px;min-width:240px;
      outline:none
    }
    input[type="password"]::placeholder{color:#7f8da3}

    /* 助记词网格 */
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{
      background:linear-gradient(180deg,#071226,#0b1526);
      border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;
      display:flex;align-items:center;gap:10px;min-height:44px
    }
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    /* 整块遮挡（覆盖在网格上） */
    .mnemo-box{position:relative}
    .mnemo-mask{
      position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);
      border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)
    }
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .reveal-btn{
      display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;
      border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;
      box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none
    }
    .hint{text-align:center;color:#9aa4b4}

    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（FIDO2 加密 + 整块遮挡）</h1>

    <!-- A. FIDO2 凭证（探测 → 数据库检查 → 复用/注册） -->
    <div class="card">
      <h3>步骤 A：注册或复用本域 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register">1) 探测/选择凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="small">将优先探测本域可发现凭证；若数据库存在记录则直接跳转钱包页面。</div>
    </div>

    <!-- B. 生成 & 展示（默认遮挡，点击显示 60s） -->
    <div class="card">
      <h3>步骤 B：生成助记词（默认整块遮挡；点击显示 60 秒）</h3>

      <!-- 备份勾选 -->
      <div class="row">
        <label><input id="cb-backup" type="checkbox"> 生成并下载离线加密备份（仅 JSON 密文，不显示助记词）</label>
      </div>

      <!-- 备份密码区块（默认隐藏，勾选时显示） -->
      <div id="backup-area" style="display:none;margin:6px 0 2px 0">
        <div class="small" style="margin-bottom:6px">
          备份密码仅用于本地加密 JSON 文件，永不上传。要求：
          <strong>≥ 8 位</strong>，包含<strong>大小写字母</strong>，并包含<strong>数字或特殊字符</strong>之一。
        </div>
        <div class="row" style="flex-wrap:wrap;gap:10px">
          <input id="pw1" type="password" placeholder="备份密码">
          <input id="pw2" type="password" placeholder="再次输入备份密码">
        </div>
        <div class="small" id="pw-tip"></div>
      </div>

      <!-- 生成按钮 -->
      <div class="row">
        <button id="btn-gen" disabled>2) 生成助记词</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <!-- 助记词卡片：网格 + 整块遮挡 -->
      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box" id="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 蒙层：默认可见；点击显示 60s -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <button class="reveal-btn" id="btn-reveal">点击显示助记词（60 秒）</button>
              <div class="hint" id="mask-hint">默认遮挡；显示时需使用 FIDO2 解锁密文。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 加密并写库 -->
    <div class="card">
      <h3>步骤 C：加密 xpub/xprv 并写入数据库</h3>
      <div class="row">
        <button id="btn-encrypt" disabled>3) 加密并写入数据库</button>
        <span id="encrypt-tip" class="muted"></span>
      </div>
      <div class="small">bundle 不包含助记词明文；仅存各链密文与 KEK 元信息。</div>
    </div>

    <div class="small" id="final"></div>
  </div>


<script type="module">
/* ===== 依赖（与当前 fido2.js 保持一致） ===== */
import {
  loadCredHex, saveCredHex,
  ensureCredentialWithChoice,
  deriveKEKWithSalt,
  aesGcmEncryptStr, aesGcmDecryptStr,
} from './js/fido2.js';

import {
  genMnemonic, mnemonicToSeed, exportBranches
} from './js/hdwallet-core.js';

/* ===== 配置 ===== */
const API_BASE   = 'https://wallet.lucas-l-shang.workers.dev';
const REVEAL_MS  = 60_000;         // 显示助记词 60s
const PBKDF2_ITR = 210_000;        // 离线备份 KDF 轮数（浏览器可承受范围内偏强）
const PW_MIN_LEN = 8;

/* ===== 状态 ===== */
const state = {
  selectedCredHex: null,  // A 步骤绑定；库中“无记录”才允许初始化
  sealed: null,           // { mnemo:{nonce,ciphertext}, saltHex, credId, rp_id, info }
  sealedChains: null,     // 各链密文（FIDO2 加密）
  branchesPub: null,      // 各链公开数据（xpub/path）
  wordCount: 12,
  autoMaskTimer: null,

  // 备份相关
  wantBackup: false,
  pw1: '',
  pw2: '',
};

/* ===== DOM 工具 ===== */
const $ = id => document.getElementById(id);
const enable = (id, on)=>{ const b=$(id); if(b) b.disabled = !on; };
function showCard(){ const c=$('mnemo-card'); if(c)c.style.display='block'; }
function showMask(){ const m=$('mnemo-mask'); if(m)m.style.display='flex'; }
function hideMask(){ const m=$('mnemo-mask'); if(m)m.style.display='none'; }
function clearAutoMask(){ if(state.autoMaskTimer){ clearTimeout(state.autoMaskTimer); state.autoMaskTimer=null; } }
function renderGrid(words){
  const grid=$('mnemo-grid'); if(!grid) return;
  grid.innerHTML='';
  words.forEach((w,i)=>{
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML=`<span class="badge">${i+1}</span><span class="word">${w}</span>`;
    grid.appendChild(d);
  });
}
function renderMasked(n=12){ renderGrid(Array.from({length:n},()=> '•••••')); }
const toHex = (u8) => [...new Uint8Array(u8)].map(b=>b.toString(16).padStart(2,'0')).join('');

/* ===== 按 credHex 查库（兼容两种返回结构） ===== */
async function fetchBundleByCred(credHex){
  const resp = await fetch(`${API_BASE}/bundles/by-cred/${credHex}`);
  if (resp.status === 404) return null;
  const data = await resp.json().catch(()=> ({}));
  if (!resp.ok || data?.ok === false) throw new Error(data?.error || `HTTP ${resp.status}`);
  if (data.bundle) return data.bundle;
  if (Array.isArray(data.items)   && data.items.length)   return data.items[0];
  if (Array.isArray(data.results) && data.results.length) return data.results[0];
  return null;
}

/* ===== 密码强度校验 & UI 绑定 ===== */
function validatePassword(pw){
  if (!pw || pw.length < PW_MIN_LEN) return { ok:false, reason:`至少 ${PW_MIN_LEN} 位` };
  const hasLower = /[a-z]/.test(pw);
  const hasUpper = /[A-Z]/.test(pw);
  const hasNum   = /\d/.test(pw);
  const hasSpec  = /[^A-Za-z0-9]/.test(pw);
  if (!(hasLower && hasUpper && (hasNum || hasSpec))) {
    return { ok:false, reason:'需含大小写字母，且包含数字或特殊字符' };
  }
  return { ok:true };
}
function refreshGenButton(){
  // 只有在 A 步骤完成且（未勾选备份 或 密码合格且一致）时，才允许生成
  const credOK = !!state.selectedCredHex;
  let pwOK = true;
  if (state.wantBackup){
    const v = validatePassword(state.pw1);
    pwOK = v.ok && (state.pw1 === state.pw2);
  }
  enable('btn-gen', credOK && pwOK);
}

function bindBackupUI(){
  const cb = $('cb-backup');
  const area = $('backup-area');
  const p1 = $('pw1');
  const p2 = $('pw2');
  const tip = $('pw-tip');

  if (!cb) return;               // 没有相关 UI 则不启用备份逻辑
  if (area) area.style.display = 'none';

  cb.onchange = ()=>{
    state.wantBackup = !!cb.checked;
    if (area) area.style.display = cb.checked ? 'block' : 'none';
    if (!cb.checked){
      state.pw1 = state.pw2 = '';
      if (tip) tip.textContent = '';
    }
    refreshGenButton();
  };

  const onPwInput = ()=>{
    state.pw1 = p1?.value || '';
    state.pw2 = p2?.value || '';
    if (!state.wantBackup){ if(tip) tip.textContent=''; refreshGenButton(); return; }
    if (!state.pw1 && !state.pw2){ if(tip) tip.textContent=''; refreshGenButton(); return; }
    if (state.pw1 !== state.pw2){ if(tip) tip.innerHTML='<span class="err">两次输入不一致</span>'; refreshGenButton(); return; }
    const v = validatePassword(state.pw1);
    if (!v.ok){ if(tip) tip.innerHTML = `<span class="err">${v.reason}</span>`; refreshGenButton(); return; }
    if (tip) tip.innerHTML = '<span class="ok">密码强度通过</span>';
    refreshGenButton();
  };

  if (p1) p1.oninput = onPwInput;
  if (p2) p2.oninput = onPwInput;
}

/* ===== PBKDF2 → AES-GCM（用于离线备份，仅用用户密码） ===== */
async function derivePasswordAesKey(password, saltU8, iterations=PBKDF2_ITR){
  const te = new TextEncoder();
  const keyMat = await crypto.subtle.importKey('raw', te.encode(password), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', hash:'SHA-256', salt: saltU8, iterations },
    keyMat, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']
  );
}
async function encryptMnemonicWithPassword(mnemonic, password){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const key  = await derivePasswordAesKey(password, salt, PBKDF2_ITR);
  const iv   = crypto.getRandomValues(new Uint8Array(12));
  const ct   = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, new TextEncoder().encode(mnemonic));
  return {
    version: 1,
    created_at: Math.floor(Date.now()/1000),
    kdf:   { name:'PBKDF2', hash:'SHA-256', iterations: PBKDF2_ITR, salt: toHex(salt) },
    cipher:{ name:'AES-GCM', iv: toHex(iv) },
    ciphertext: toHex(new Uint8Array(ct))
  };
}
function downloadJson(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], { type:'application/json' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 1500);
}

/* ===== 初始：禁止生成；绑定备份 UI ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  enable('btn-gen', false);
  bindBackupUI();
});

/* ===== 步骤 A：注册/选择凭证 → 查库：存在则禁止并跳转 ===== */
$('btn-register').onclick = async ()=>{
  const tip=$('reg-tip');
  try{
    const res  = await ensureCredentialWithChoice();
    const cred = res?.id_hex;
    if (!cred) throw new Error('未获得有效凭证');
    saveCredHex(cred);

    const exists = await fetchBundleByCred(cred);
    if (exists) {
      state.selectedCredHex = null;
      enable('btn-gen', false);
      if (tip) tip.innerHTML = `<span class="err">该凭证已在数据库注册，禁止重复初始化；即将跳转钱包页。</span>`;
      setTimeout(()=>{ location.href = `wallet.html?cred=${cred}`; }, 1000);
      return;
    }

    state.selectedCredHex = cred;
    if (tip) tip.innerHTML = `<span class="ok">已注册/绑定凭证（id: ${cred.slice(0,16)}…）。</span>`;
    refreshGenButton();
  }catch(e){
    console.error(e);
    if (tip) tip.innerHTML = `<span class="err">凭证注册/绑定失败：${e?.message||e}</span>`;
  }
};

/* ===== 步骤 B：生成（若勾选备份则必须先通过密码校验；生成时立刻离线加密并下载 JSON） ===== */
$('btn-gen').onclick = async ()=>{
  const tip=$('gen-tip');
  try{
    if(!state.selectedCredHex) throw new Error('请先完成步骤 A。');

    // 二次校验：防并发
    const again = await fetchBundleByCred(state.selectedCredHex);
    if (again) {
      enable('btn-gen', false);
      tip.innerHTML = `<span class="err">该凭证刚刚已在数据库出现，禁止继续初始化，正在跳转钱包页。</span>`;
      setTimeout(()=>{ location.href = `wallet.html?cred=${state.selectedCredHex}`; }, 1000);
      return;
    }

    // 如果勾选备份，要求密码已合格
    if (state.wantBackup){
      const v = validatePassword(state.pw1);
      if (!v.ok || state.pw1 !== state.pw2) throw new Error('备份密码未通过校验');
    }

    // 生成 + 分支
    const mnemonic = genMnemonic(128);
    const words    = mnemonic.trim().split(/\s+/);
    state.wordCount= words.length || 12;
    const seed     = mnemonicToSeed(mnemonic,'');
    const branches = exportBranches(seed);

    // FIDO2 派生同把 cred 的 KEK（随机盐）→ 加密：助记词 + 链私钥
    const salt = crypto.getRandomValues(new Uint8Array(32));
    const { kek } = await deriveKEKWithSalt(state.selectedCredHex, salt);

    // 助记词密文（FIDO）
    const mnEnc = await aesGcmEncryptStr(kek, mnemonic);

    // 各链密文（FIDO；不同 nonce，绝不复用）
    const enc = async (s)=> s ? await aesGcmEncryptStr(kek, s) : null;
    const sealedChains = {
      ETH:  { path: branches.ETH.path,  PubEnc: await enc(branches.ETH.xpub),   PrivEnc: await enc(branches.ETH.xprv) },
      BTC:  { path: branches.BTC.path,  PubEnc: await enc(branches.BTC.xpub_z), PrivEnc: await enc(branches.BTC.xprv_z) },
      EOS:  { path: branches.EOS.path,  PubEnc: await enc(branches.EOS.xpub),   PrivEnc: await enc(branches.EOS.xprv) },
      TRON: { path: branches.TRON.path, PubEnc: await enc(branches.TRON.xpub),  PrivEnc: await enc(branches.TRON.xprv) },
    };

    // 公开信息
    state.branchesPub = {
      ETH:  { path: branches.ETH.path,  xpub: branches.ETH.xpub },
      BTC:  { path: branches.BTC.path,  xpub_z: branches.BTC.xpub_z },
      EOS:  { path: branches.EOS.path,  xpub: branches.EOS.xpub },
      TRON: { path: branches.TRON.path, xpub: branches.TRON.xpub },
    };

    // 记录 FIDO 密封体
    state.sealed = {
      mnemo:   { nonce: mnEnc.nonce, ciphertext: mnEnc.ciphertext },
      saltHex: toHex(salt),
      credId:  state.selectedCredHex,
      rp_id:   location.hostname,
      info:    'wallet-priv-bundle-v1',
    };
    state.sealedChains = sealedChains;

    // ★ 若勾选备份：在“仍握有明文”的这一刻，用用户密码离线加密并立刻下载 JSON
    if (state.wantBackup){
      const backup = await encryptMnemonicWithPassword(mnemonic, state.pw1);
      downloadJson(backup, 'mnemonic_backup.enc.json');
      // 擦除密码与提示
      state.pw1 = state.pw2 = '';
      const tipPw = $('pw-tip'); if (tipPw) tipPw.textContent='';
      const p1 = $('pw1'); if (p1) p1.value='';
      const p2 = $('pw2'); if (p2) p2.value='';
    }

    // UI：默认整块遮挡（不自动显示助记词）
    showCard(); renderMasked(state.wordCount); showMask();
    tip.textContent = state.wantBackup ? '已生成并下载离线备份；已完成 FIDO2 加密。' : '已生成并完成 FIDO2 加密（默认遮挡）。';
    enable('btn-encrypt', true);

    // 擦本地私钥副本
    for (const k of ['ETH','BTC','EOS','TRON']) {
      if (branches[k]) {
        if ('xprv'   in branches[k]) branches[k].xprv   = null;
        if ('xprv_z' in branches[k]) branches[k].xprv_z = null;
      }
    }
  }catch(e){
    console.error(e);
    tip.innerHTML = `<span class="err">生成失败：${e?.message||e}</span>`;
  }
};

/* ===== 显示助记词：点击 → FIDO2 解密 → 显示 60s → 遮挡 ===== */
$('btn-reveal').onclick = async ()=>{
  try{
    if(!state.sealed?.mnemo) throw new Error('尚未生成');
    if(!state.selectedCredHex || state.selectedCredHex !== state.sealed.credId){
      throw new Error('当前凭证与绑定的不一致，无法解锁。');
    }
    const { kek } = await deriveKEKWithSalt(state.selectedCredHex, state.sealed.saltHex);
    const mnemonic = await aesGcmDecryptStr(kek, state.sealed.mnemo);
    const words    = mnemonic.trim().split(/\s+/);

    renderGrid(words);
    hideMask();

    clearAutoMask();
    state.autoMaskTimer = setTimeout(()=>{
      renderMasked(state.wordCount);
      showMask();
      try{ for(let i=0;i<words.length;i++) words[i]=''; }catch{}
    }, REVEAL_MS);
  }catch(e){
    console.error(e);
    const hint = $('mask-hint');
    if(hint) hint.textContent = `解锁失败：${e?.message||e}`;
    setTimeout(()=>{ if(hint) hint.textContent='默认遮挡；显示时需使用 FIDO2 解锁密文。'; }, 1800);
  }
};

/* ===== 步骤 C：写库（前置终检） ===== */
$('btn-encrypt').onclick = async ()=>{
  const tip=$('encrypt-tip');
  try{
    if(!state.selectedCredHex) throw new Error('请先完成步骤 A');
    if(!state.sealed || !state.sealedChains) throw new Error('尚未生成');
    if(state.selectedCredHex !== state.sealed.credId){
      throw new Error('当前凭证与已绑定的不一致，禁止写库。');
    }

    // 最终防线
    const exists = await fetchBundleByCred(state.selectedCredHex);
    if (exists) {
      tip.textContent = '';
      alert('该凭证已在数据库注册，禁止重复写库，正在跳转钱包页。');
      location.href = `wallet.html?cred=${state.selectedCredHex}`;
      return;
    }

    const bundle = {
      KEKInfo:{
        rp_id: state.sealed.rp_id,
        info:  state.sealed.info,
        salt:  state.sealed.saltHex,
        credential_id: state.sealed.credId
      },
      chains: state.sealedChains
    };

    tip.textContent = '正在写入数据库…';
    const resp = await fetch(`${API_BASE}/bundles`, {
      method:'POST', headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ user_id:'web-ui', note:'初始化保存（UI）', bundle })
    });
    const data = await resp.json().catch(()=> ({}));
    if(!resp.ok || !data?.ok) throw new Error(data?.error || `HTTP ${resp.status}`);

    tip.textContent = '';
    alert(`写入成功：bundle_id=${data.bundle_id}`);
    location.href = `wallet.html?cred=${state.selectedCredHex}`;
  }catch(e){
    tip.textContent = '';
    alert('写入失败：'+(e?.message||e));
    console.error(e);
  }
};
</script>

</body>
</html>
