<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（FIDO2 加密 + 整块遮挡）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;--line:#1f2937;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0}
    .muted{color:var(--muted)}
    button{
      background:linear-gradient(180deg,#0f172a,#091427);border:1px solid rgba(255,255,255,0.06);
      color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer
    }
    button:hover{filter:brightness(1.06)}
    button[disabled]{opacity:.45;cursor:not-allowed}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .small{font-size:13px;color:var(--muted)}

    /* 助记词网格 */
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{
      background:linear-gradient(180deg,#071226,#0b1526);
      border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;
      display:flex;align-items:center;gap:10px;min-height:44px
    }
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    /* 整块遮挡（覆盖在网格上） */
    .mnemo-box{position:relative}
    .mnemo-mask{
      position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);
      border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)
    }
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .reveal-btn{
      display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;
      border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;
      box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none
    }
    .hint{text-align:center;color:#9aa4b4}
    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（FIDO2 加密 + 整块遮挡）</h1>

    <!-- A. FIDO2 凭证（探测 → 数据库检查 → 复用/注册） -->
    <div class="card">
      <h3>步骤 A：注册或复用本域 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register">1) 探测/选择凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="small">将优先探测本域可发现凭证；若数据库存在记录则直接跳转钱包页面。</div>
    </div>

    <!-- B. 生成 & 展示（默认遮挡，点击显示 60s） -->
    <div class="card">
      <h3>步骤 B：生成助记词（默认整块遮挡；点击显示 60 秒）</h3>
      <div class="row">
        <label><input id="cb-backup" type="checkbox"> 生成并下载离线加密备份（仅 JSON 密文，不显示助记词）</label>
      </div>
      <div class="row">
        <button id="btn-gen" disabled>2) 生成助记词</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <!-- 助记词卡片：网格 + 整块遮挡 -->
      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box" id="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 蒙层：默认可见；点击显示 60s -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <button class="reveal-btn" id="btn-reveal">点击显示助记词（60 秒）</button>
              <div class="hint" id="mask-hint">默认遮挡；显示时需使用 FIDO2 解锁密文。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 加密并写库 -->
    <div class="card">
      <h3>步骤 C：加密 xpub/xprv 并写入数据库</h3>
      <div class="row">
        <button id="btn-encrypt" disabled>3) 加密并写入数据库</button>
        <span id="encrypt-tip" class="muted"></span>
      </div>
      <div class="small">bundle 不包含助记词明文；仅存各链密文与 KEK 元信息。</div>
    </div>

    <div class="small" id="final"></div>
  </div>

<script type="module">
/* ===== 依赖（与现有 fido2.js 保持一致） ===== */
import {
  loadCredHex, saveCredHex,
  ensureCredentialWithChoice,
  deriveKEKWithSalt,
  aesGcmEncryptStr, aesGcmDecryptStr,
} from './js/fido2.js';

import {
  genMnemonic, mnemonicToSeed, exportBranches
} from './js/hdwallet-core.js';

/* ===== 配置 ===== */
const API_BASE  = 'https://wallet.lucas-l-shang.workers.dev';
const REVEAL_MS = 60_000;

/* ===== 状态 ===== */
const state = {
  selectedCredHex: null,  // 仅当“该 cred 数据库无记录”时才允许赋值
  sealed: null,           // { mnemo:{nonce,ciphertext}, saltHex, credId, rp_id, info }
  sealedChains: null,     // 各链密文
  branchesPub: null,      // 各链公开数据（xpub/path）
  wordCount: 12,
  autoMaskTimer: null,
};

/* ===== DOM 工具 ===== */
const $ = id => document.getElementById(id);
const enable = (id, on)=>{ const b=$(id); if(b) b.disabled = !on; };
function showCard(){ const c=$('mnemo-card'); if(c)c.style.display='block'; }
function showMask(){ const m=$('mnemo-mask'); if(m)m.style.display='flex'; }
function hideMask(){ const m=$('mnemo-mask'); if(m)m.style.display='none'; }
function clearAutoMask(){ if(state.autoMaskTimer){ clearTimeout(state.autoMaskTimer); state.autoMaskTimer=null; } }
function renderGrid(words){
  const grid=$('mnemo-grid'); if(!grid) return;
  grid.innerHTML='';
  words.forEach((w,i)=>{
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML=`<span class="badge">${i+1}</span><span class="word">${w}</span>`;
    grid.appendChild(d);
  });
}
function renderMasked(n=12){ renderGrid(Array.from({length:n},()=> '•••••')); }

/* ===== 通用：按 credHex 查是否已在库里（兼容你两种返回结构） ===== */
async function fetchBundleByCred(credHex){
  const resp = await fetch(`${API_BASE}/bundles/by-cred/${credHex}`);
  if (resp.status === 404) return null;
  const data = await resp.json().catch(()=> ({}));
  if (!resp.ok || data?.ok === false) throw new Error(data?.error || `HTTP ${resp.status}`);

  // 支持两种后端形态：{bundle} 或 {count, items[]} / {results[]}
  if (data.bundle) return data.bundle;
  if (Array.isArray(data.items) && data.items.length) return data.items[0];
  if (Array.isArray(data.results) && data.results.length) return data.results[0];
  return null;
}

/* ===== 初始：禁止生成，直到通过 A 步骤绑定 cred 并确认库中无记录 ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  enable('btn-gen', false);
});

/* ===== 步骤 A：注册/选择凭证 → 立刻查库 → 若存在则禁止并跳转 ===== */
$('btn-register').onclick = async ()=>{
  const tip=$('reg-tip');
  try{
    const res  = await ensureCredentialWithChoice();      // 可能选择已有 discoverable，或创建新凭证
    const cred = res?.id_hex;
    if (!cred) throw new Error('未获得有效凭证');
    saveCredHex(cred);

    const exists = await fetchBundleByCred(cred);
    if (exists) {
      // ★ 已存在：严格禁止继续，并跳转
      state.selectedCredHex = null;
      enable('btn-gen', false);
      if (tip) tip.innerHTML = `<span class="err">该凭证已在数据库注册（禁止重复初始化），即将跳转钱包页。</span>`;
      setTimeout(()=>{ location.href = `wallet.html?cred=${cred}`; }, 1000);
      return;
    }

    // ★ 不存在：允许继续
    state.selectedCredHex = cred;
    enable('btn-gen', true);
    if (tip) tip.innerHTML = `<span class="ok">已注册/绑定凭证（id: ${cred.slice(0,16)}…），可继续生成助记词。</span>`;
  }catch(e){
    console.error(e);
    if (tip) tip.innerHTML = `<span class="err">凭证注册/绑定失败：${e?.message||e}</span>`;
  }
};

/* ===== 步骤 B：生成（生成前再次校验该 cred 是否突然已被写库） ===== */
$('btn-gen').onclick = async ()=>{
  const tip=$('gen-tip');
  try{
    if(!state.selectedCredHex) throw new Error('请先完成步骤 A。');

    // 二次防线：生成前再查一次库（防止并发或用户开多标签页）
    const again = await fetchBundleByCred(state.selectedCredHex);
    if (again) {
      enable('btn-gen', false);
      tip.innerHTML = `<span class="err">该凭证刚刚已在数据库出现，禁止继续初始化，正在跳转钱包页。</span>`;
      setTimeout(()=>{ location.href = `wallet.html?cred=${state.selectedCredHex}`; }, 1000);
      return;
    }

    // 生成助记词 & 分支
    const mnemonic = genMnemonic(128);
    const words    = mnemonic.trim().split(/\s+/);
    state.wordCount= words.length || 12;
    const seed     = mnemonicToSeed(mnemonic,'');
    const branches = exportBranches(seed);

    // 用步骤 A 绑定的同一把凭证 + 随机盐 派生 KEK 加密
    const salt = crypto.getRandomValues(new Uint8Array(32));
    const { kek } = await deriveKEKWithSalt(state.selectedCredHex, salt);

    // 助记词密文
    const mnEnc = await aesGcmEncryptStr(kek, mnemonic);

    // 各链密文（不同 nonce，绝不复用）
    const enc = async (s)=> s ? await aesGcmEncryptStr(kek, s) : null;
    const sealedChains = {
      ETH:  { path: branches.ETH.path,  PubEnc: await enc(branches.ETH.xpub),   PrivEnc: await enc(branches.ETH.xprv) },
      BTC:  { path: branches.BTC.path,  PubEnc: await enc(branches.BTC.xpub_z), PrivEnc: await enc(branches.BTC.xprv_z) },
      EOS:  { path: branches.EOS.path,  PubEnc: await enc(branches.EOS.xpub),   PrivEnc: await enc(branches.EOS.xprv) },
      TRON: { path: branches.TRON.path, PubEnc: await enc(branches.TRON.xpub),  PrivEnc: await enc(branches.TRON.xprv) },
    };

    // 仅保留公开部分
    state.branchesPub = {
      ETH:  { path: branches.ETH.path,  xpub: branches.ETH.xpub },
      BTC:  { path: branches.BTC.path,  xpub_z: branches.BTC.xpub_z },
      EOS:  { path: branches.EOS.path,  xpub: branches.EOS.xpub },
      TRON: { path: branches.TRON.path, xpub: branches.TRON.xpub },
    };

    // 擦除私钥副本
    for (const k of ['ETH','BTC','EOS','TRON']) {
      if (branches[k]) {
        if ('xprv'   in branches[k]) branches[k].xprv   = null;
        if ('xprv_z' in branches[k]) branches[k].xprv_z = null;
      }
    }

    const toHex = (u8) => [...new Uint8Array(u8)].map(b=>b.toString(16).padStart(2,'0')).join('');
    state.sealed = {
      mnemo:   { nonce: mnEnc.nonce, ciphertext: mnEnc.ciphertext },
      saltHex: toHex(salt),
      credId:  state.selectedCredHex,
      rp_id:   location.hostname,
      info:    'wallet-priv-bundle-v1',
    };
    state.sealedChains = sealedChains;

    // UI：默认整块遮挡
    showCard();
    renderMasked(state.wordCount);
    showMask();
    tip.textContent = '已生成并加密（默认遮挡）。';
    enable('btn-encrypt', true);
  }catch(e){
    console.error(e);
    tip.innerHTML = `<span class="err">生成失败：${e?.message||e}</span>`;
  }
};

/* ===== 显示助记词：点击 → FIDO2 解密 → 显示 60s → 遮挡 ===== */
$('btn-reveal').onclick = async ()=>{
  try{
    if(!state.sealed?.mnemo) throw new Error('尚未生成');
    if(!state.selectedCredHex || state.selectedCredHex !== state.sealed.credId){
      throw new Error('当前凭证与绑定的不一致，无法解锁。');
    }
    // 仍然再查一次库（允许用户查看，但这里不中断写库逻辑；只是解密显示）
    const { kek } = await deriveKEKWithSalt(state.selectedCredHex, state.sealed.saltHex);
    const mnemonic = await aesGcmDecryptStr(kek, state.sealed.mnemo);
    const words    = mnemonic.trim().split(/\s+/);

    renderGrid(words);
    hideMask();

    clearAutoMask();
    state.autoMaskTimer = setTimeout(()=>{
      renderMasked(state.wordCount);
      showMask();
      try{ for(let i=0;i<words.length;i++) words[i]=''; }catch{}
    }, REVEAL_MS);
  }catch(e){
    console.error(e);
    const hint = $('mask-hint');
    if(hint) hint.textContent = `解锁失败：${e?.message||e}`;
    setTimeout(()=>{ if(hint) hint.textContent='默认遮挡；显示时需使用 FIDO2 解锁密文。'; }, 1800);
  }
};

/* ===== 步骤 C：写库（写入前最后再校验一次，若已存在则禁止写库并跳转） ===== */
$('btn-encrypt').onclick = async ()=>{
  const tip=$('encrypt-tip');
  try{
    if(!state.selectedCredHex) throw new Error('请先完成步骤 A');
    if(!state.sealed || !state.sealedChains) throw new Error('尚未生成');
    if(state.selectedCredHex !== state.sealed.credId){
      throw new Error('当前凭证与已绑定的不一致，禁止写库。');
    }

    // 最终防线：写库前再查一次
    const exists = await fetchBundleByCred(state.selectedCredHex);
    if (exists) {
      tip.textContent = '';
      alert('该凭证已在数据库注册，禁止重复写库，正在跳转钱包页。');
      location.href = `wallet.html?cred=${state.selectedCredHex}`;
      return;
    }

    const bundle = {
      KEKInfo:{
        rp_id: state.sealed.rp_id,
        info:  state.sealed.info,
        salt:  state.sealed.saltHex,
        credential_id: state.sealed.credId
      },
      chains: state.sealedChains
    };

    tip.textContent = '正在写入数据库…';
    const resp = await fetch(`${API_BASE}/bundles`, {
      method:'POST', headers:{ 'content-type':'application/json' },
      body: JSON.stringify({ user_id:'web-ui', note:'初始化保存（UI）', bundle })
    });
    const data = await resp.json().catch(()=> ({}));
    if(!resp.ok || !data?.ok) throw new Error(data?.error || `HTTP ${resp.status}`);

    tip.textContent = '';
    alert(`写入成功：bundle_id=${data.bundle_id}`);
    location.href = `wallet.html?cred=${state.selectedCredHex}`;
  }catch(e){
    tip.textContent = '';
    alert('写入失败：'+(e?.message||e));
    console.error(e);
  }
};
</script>

</body>
</html>
