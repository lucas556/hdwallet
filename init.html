<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（注册新 FIDO2 凭证）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;--line:#1f2937;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .btn{
      background:linear-gradient(180deg,#0f172a,#091427);
      border:1px solid rgba(255,255,255,0.08);
      color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer
    }
    .btn:hover{filter:brightness(1.06)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* 助记词网格 */
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{
      background:linear-gradient(180deg,#071226,#0b1526);
      border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;
      display:flex;align-items:center;gap:10px;min-height:44px
    }
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    /* 整块遮挡（覆盖在网格上） */
    .mnemo-box{position:relative}
    .mnemo-mask{
      position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);
      border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)
    }
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .mask-btn{
      display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;
      border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;
      box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none
    }
    .hint{text-align:center;color:#9aa4b4}

    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（注册新 FIDO2 凭证 → 生成即加密）</h1>

    <!-- A. 仅注册新凭证 -->
    <div class="card">
      <h3>步骤 A：注册新的本域 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register" class="btn">1) 注册新凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="muted">该步骤会创建“可发现凭证（discoverable）”。后续步骤会<strong>强制绑定同一把凭证</strong>，防止 A 步骤选 A、B 步骤却触摸 B。</div>
    </div>

    <!-- B. 生成 & 展示（生成即加密；默认整块遮挡） -->
    <div class="card">
      <h3>步骤 B：生成助记词（生成即用步骤 A 的凭证加密；默认整块遮挡）</h3>
      <div class="row">
        <button id="btn-gen" class="btn" disabled>2) 生成助记词并加密</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <!-- 助记词卡片：网格 + 整块遮挡 -->
      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 蒙层：默认可见；点击解密显示 60 秒 -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <button class="mask-btn" id="btn-reveal">显示助记词（需 FIDO2 解密）</button>
              <div class="hint" id="mask-hint">默认遮挡。点击上方按钮并完成 FIDO2 验证后，明文显示 60 秒并自动遮挡。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 写库 -->
    <div class="card">
      <h3>步骤 C：写入数据库（再次验证同一把凭证）</h3>
      <div class="row">
        <button id="btn-save" class="btn" disabled>3) 写入数据库</button>
        <span id="save-tip" class="muted"></span>
      </div>
      <div class="muted">仅写入密文，不包含助记词明文。</div>
    </div>
  </div>

<script type="module">
/* ========= 导入 ========= */
import {
  loadCredHex,
  saveCredHex,
  registerNewCredential,
  deriveKEKWithSalt,   // 供步骤 B/C 绑定同一把凭证时使用
} from './js/fido2.js';

// 你的 Worker API（按需修改）
const API_BASE = 'https://wallet.lucas-l-shang.workers.dev';

/* ========= 全局状态（本次会话绑定用哪把凭证） ========= */
let selectedCredHex = null;
function setSelectedCredHex(hex){
  selectedCredHex = hex;
  // 供其它步骤使用（B/C 从这里读同一把凭证）
  window.__selectedCredHex = hex;
  const btnGen = document.getElementById('btn-gen');
  if (btnGen) btnGen.disabled = !hex;
}

/* ========= 工具函数 ========= */

// 发现本域 discoverable credential：优先用本地缓存，
// 若无缓存则调用 WebAuthn 枚举（不传 allowCredentials）
async function discoverExistingCredentialHex() {
  // 1) 本地缓存优先
  const cached = loadCredHex?.();
  if (cached) return cached;

  // 2) 枚举 discoverable credentials
  if (!navigator.credentials?.get) return null;
  try {
    const cred = await navigator.credentials.get({
      publicKey: {
        userVerification: 'preferred',
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        timeout: 60000,
        // 不设置 allowCredentials：让设备自行枚举
      }
    });
    if (cred?.rawId) {
      const b = new Uint8Array(cred.rawId);
      let hex = ''; for (const x of b) hex += x.toString(16).padStart(2,'0');
      saveCredHex?.(hex);
      return hex;
    }
  } catch (_) {
    // 用户取消 / 没有 discoverable 凭证，都当无
  }
  return null;
}

// 查库：凭证是否已有 bundle 记录
async function checkBundleByCred(credHex) {
  const url = `${API_BASE}/bundles/by-cred/${encodeURIComponent(credHex)}`;
  try{
    const res = await fetch(url, { method: 'GET' });
    if (!res.ok) return null; // 404/403 等 => 视为无记录
    const data = await res.json().catch(()=>null);
    // 约定：{ ok:true, bundle:{...} }
    if (data?.ok && data?.bundle) return data.bundle;
  }catch{}
  return null;
}

/* ========= 初始：如果本地已有缓存的凭证，则提示“可用”，但不自动跳转 ========= */
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    const cached = loadCredHex?.();
    if (cached) {
      const tip = document.getElementById('reg-tip');
      if (tip) tip.innerHTML = `<span class="ok">检测到本地凭证缓存（id: ${cached.slice(0,16)}…），可继续。</span>`;
      setSelectedCredHex(cached); // 允许进入步骤 B
    }
  }catch{}
});

/* ========= 步骤 A：注册/选择凭证（含两种分支） ========= */
document.getElementById('btn-register').onclick = async ()=>{
  const tip = document.getElementById('reg-tip');

  try {
    // 1) 先探测是否已有 discoverable credential
    const foundHex = await discoverExistingCredentialHex();

    if (foundHex) {
      // 1.1 有凭证 → 查数据库
      const exists = await checkBundleByCred(foundHex);
      if (exists) {
        // 数据库中已有记录 → 直接提示并跳转 wallet.html
        tip.innerHTML = '<span class="ok">检测到已有凭证，且数据库存在记录，正在跳转…</span>';
        location.href = `wallet.html?cred=${encodeURIComponent(foundHex)}`;
        return;
      }

      // 1.2 有凭证但数据库无记录 → 询问是否沿用
      const use = confirm(`检测到本域凭证：${foundHex.slice(0,16)}…\n数据库中未找到记录。\n是否沿用该凭证用于初始化？`);
      if (use) {
        setSelectedCredHex(foundHex);
        if (tip) tip.innerHTML = `<span class="ok">已选择沿用凭证（id: ${foundHex.slice(0,16)}…）。可进行下一步。</span>`;
        return;
      }
      // 选择不沿用 → 走注册新凭证
    }

    // 2) 注册新凭证
    if (tip) tip.textContent = '请触摸安全钥匙以注册新凭证…';
    const reg = await registerNewCredential();
    const hex = reg?.id_hex;
    if (!hex) throw new Error('注册失败，未获得凭证 ID');

    setSelectedCredHex(hex);
    if (tip) tip.innerHTML = `<span class="ok">已注册新凭证（id: ${hex.slice(0,16)}…）。可进行下一步。</span>`;
  } catch (e) {
    console.error(e);
    if (tip) tip.innerHTML = `<span class="err">处理失败：${e?.message || e}</span>`;
  }
};

/* =========（可选）在步骤 B/C 前强绑定同一把凭证的示例 =========
   - 生成/解密/写库前，你可以用 deriveKEKWithSalt(selectedCredHex, someSalt)
     来“再认证”，确保用户仍在使用步骤 A 绑定的同一把钥匙。
   - 这里不直接改你 B/C 的逻辑；只暴露 window.__selectedCredHex 供复用。
============================================================== */
</script>

</body>
</html>
