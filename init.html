<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>助记词初始化（注册新 FIDO2 凭证）</title>
  <style>
    :root{
      --bg:#0b1220;--card:#0f1724;--muted:#9ca3af;--text:#e5e7eb;
      --accent:#60a5fa;--good:#10b981;--bad:#ef4444;--line:#1f2937;
    }
    html,body{background:var(--bg);color:var(--text);margin:0;font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,sans-serif;}
    .wrap{max-width:980px;margin:32px auto;padding:18px}
    h1{margin:0 0 12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px;margin-bottom:18px;box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .row{display:flex;align-items:center;gap:12px;margin:12px 0;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .btn{
      background:linear-gradient(180deg,#0f172a,#091427);
      border:1px solid rgba(255,255,255,0.08);
      color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer
    }
    .btn:hover{filter:brightness(1.06)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* 助记词网格 */
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .cell{
      background:linear-gradient(180deg,#071226,#0b1526);
      border:1px dashed rgba(255,255,255,.06);border-radius:12px;padding:10px;
      display:flex;align-items:center;gap:10px;min-height:44px
    }
    .badge{width:26px;height:26px;border-radius:999px;background:#0b1328;display:grid;place-items:center;color:#9fb4d9}

    /* 整块遮挡（覆盖在网格上） */
    .mnemo-box{position:relative}
    .mnemo-mask{
      position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(ellipse at center, rgba(15,23,42,.78) 0%, rgba(2,6,23,.9) 100%);
      border:1px dashed #334155;border-radius:14px;backdrop-filter:blur(6px)
    }
    .mask-inner{display:flex;flex-direction:column;align-items:center;gap:10px}
    .mask-btn{
      display:flex;align-items:center;gap:10px;border-radius:999px;padding:12px 16px;
      border:1px solid #1f2a44;background:#0b1328;color:#cfe1ff;cursor:pointer;
      box-shadow:0 8px 22px rgba(0,0,0,.28);user-select:none
    }
    .hint{text-align:center;color:#9aa4b4}

    @media (max-width:700px){ .grid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>助记词初始化（注册新 FIDO2 凭证 → 生成即加密）</h1>

    <!-- A. 仅注册新凭证 -->
    <div class="card">
      <h3>步骤 A：注册新的本域 FIDO2 凭证</h3>
      <div class="row">
        <button id="btn-register" class="btn">1) 注册新凭证</button>
        <span id="reg-tip" class="muted"></span>
      </div>
      <div class="muted">该步骤会创建“可发现凭证（discoverable）”。后续步骤会<strong>强制绑定同一把凭证</strong>，防止 A 步骤选 A、B 步骤却触摸 B。</div>
    </div>

    <!-- B. 生成 & 展示（生成即加密；默认整块遮挡） -->
    <div class="card">
      <h3>步骤 B：生成助记词（生成即用步骤 A 的凭证加密；默认整块遮挡）</h3>
      <div class="row">
        <button id="btn-gen" class="btn" disabled>2) 生成助记词并加密</button>
        <span id="gen-tip" class="muted"></span>
      </div>

      <!-- 助记词卡片：网格 + 整块遮挡 -->
      <div id="mnemo-card" style="display:none;margin-top:10px">
        <div class="mnemo-box">
          <div class="grid" id="mnemo-grid"></div>

          <!-- 蒙层：默认可见；点击解密显示 60 秒 -->
          <div class="mnemo-mask" id="mnemo-mask">
            <div class="mask-inner">
              <button class="mask-btn" id="btn-reveal">显示助记词（需 FIDO2 解密）</button>
              <div class="hint" id="mask-hint">默认遮挡。点击上方按钮并完成 FIDO2 验证后，明文显示 60 秒并自动遮挡。</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C. 写库 -->
    <div class="card">
      <h3>步骤 C：写入数据库（再次验证同一把凭证）</h3>
      <div class="row">
        <button id="btn-save" class="btn" disabled>3) 写入数据库</button>
        <span id="save-tip" class="muted"></span>
      </div>
      <div class="muted">仅写入密文，不包含助记词明文。</div>
    </div>
  </div>

<script type="module">
/* ===== 依赖 ===== */
import {
  registerNewCredential,
  deriveKEKWithSalt,
  aesGcmEncryptStr,
  aesGcmDecryptStr
} from './js/fido2.js';

import { genMnemonic, mnemonicToSeed, exportBranches } from './js/hdwallet-core.js';

/* ===== 常量与状态 ===== */
const API_BASE   = 'https://wallet.lucas-l-shang.workers.dev';
const REVEAL_MS  = 60_000;  // 展示 60 秒

let selectedCredHex = '';   // 步骤 A 注册得到的唯一凭证
let sealed = null;          // 生成阶段产物（只存密文）
/*
sealed = {
  credId, rp_id, info, saltHex,
  mnemonicEnc:{nonce,ciphertext},
  chains:{
    ETH:{ path, PubEnc:null, PrivEnc:{nonce,ciphertext} },
    BTC:{ ... }, EOS:{...}, TRON:{...}
  }
}
*/
let revealTimer = null;

/* ===== DOM 工具 ===== */
const $ = id => document.getElementById(id);
function clearTimer(){ if(revealTimer){ clearTimeout(revealTimer); revealTimer=null; } }
function maskAll(note=''){ $('mnemo-mask').style.display='flex'; if(note) $('mask-hint').textContent=note; }
function unmask(){ $('mnemo-mask').style.display='none'; }
function renderMaskedGrid(n){
  const grid=$('mnemo-grid'); grid.innerHTML='';
  for(let i=0;i<n;i++){
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML=`<span class="badge">${i+1}</span><span>•••••</span>`;
    grid.appendChild(d);
  }
}
function renderWords(words){
  const g=$('mnemo-grid'); g.innerHTML='';
  words.forEach((w,i)=>{
    const d=document.createElement('div'); d.className='cell';
    d.innerHTML = `<span class="badge">${i+1}</span><span>${w}</span>`;
    g.appendChild(d);
  });
}

/* ===== A：注册新的凭证 ===== */
$('btn-register').onclick = async ()=>{
  const tip=$('reg-tip');
  try{
    const { id_hex } = await registerNewCredential(); // 仅注册，不复用
    selectedCredHex = id_hex;
    tip.innerHTML = `<span class="ok">已注册新凭证：${id_hex.slice(0,16)}…</span>`;
    $('btn-gen').disabled = false;
  }catch(e){
    tip.innerHTML = `<span class="err">注册失败：${e?.message||e}</span>`;
    console.error(e);
  }
};

/* ===== B：生成（立刻加密） ===== */
$('btn-gen').onclick = async ()=>{
  const tip=$('gen-tip');
  if(!selectedCredHex){
    tip.innerHTML = '<span class="err">请先完成步骤 A（注册新凭证）。</span>';
    return;
  }
  try{
    // 1) 生成助记词 & 各链分支（在内存临时变量里）
    const mnemonic = genMnemonic(128);
    const words    = mnemonic.trim().split(/\s+/);
    const seed     = mnemonicToSeed(mnemonic, '');
    const branches = exportBranches(seed);

    // 2) 立刻加密：用“步骤 A 的同一把凭证 + 随机 salt”
    const salt = crypto.getRandomValues(new Uint8Array(32));
    const { kek, rp_id, info } = await deriveKEKWithSalt(selectedCredHex, salt);

    // 助记词密文
    const mnemonicEnc = await aesGcmEncryptStr(kek, mnemonic);
    // 各链私钥密文；公钥/xpub 不必加密就不传，或按需加密
    const enc = async s => s ? await aesGcmEncryptStr(kek, s) : null;

    sealed = {
      credId: selectedCredHex,
      rp_id, info,
      saltHex: [...salt].map(b=>b.toString(16).padStart(2,'0')).join(''),
      mnemonicEnc,
      chains:{
        ETH:  { path: branches.ETH.path,  PubEnc:null,                    PrivEnc: await enc(branches.ETH.xprv)   },
        BTC:  { path: branches.BTC.path,  PubEnc:null,                    PrivEnc: await enc(branches.BTC.xprv_z) },
        EOS:  { path: branches.EOS.path,  PubEnc:null,                    PrivEnc: await enc(branches.EOS.xprv)   },
        TRON: { path: branches.TRON.path, PubEnc:null,                    PrivEnc: await enc(branches.TRON.xprv)  }
      }
    };

    // 3) 展示卡片（默认整块遮挡）
    $('mnemo-card').style.display = 'block';
    renderMaskedGrid(words.length);
    maskAll('默认遮挡。点击“显示助记词”并完成 FIDO2 验证后，明文显示 60 秒。');

    // 清理明文中间变量
    try{ for(let i=0;i<words.length;i++) words[i]=''; }catch{}
    tip.innerHTML = '<span class="ok">已生成并加密。</span>';
    $('btn-save').disabled = false;
  }catch(e){
    tip.innerHTML = `<span class="err">生成失败：${e?.message||e}</span>`;
    console.error(e);
  }
};

/* 显示助记词（始终需 FIDO2 解密） */
$('btn-reveal').onclick = async ()=>{
  clearTimer();
  try{
    if(!sealed?.credId){ throw new Error('尚未生成'); }
    const salt = new Uint8Array(sealed.saltHex.match(/../g).map(h=>parseInt(h,16)));
    // 派生（同一把凭证 + 保存的 salt）
    const { kek } = await deriveKEKWithSalt(sealed.credId, salt);
    const mnemonic = await aesGcmDecryptStr(kek, sealed.mnemonicEnc);
    const words    = mnemonic.trim().split(/\s+/);

    renderWords(words);
    unmask();

    // 60 秒后自动遮挡并擦干净
    revealTimer = setTimeout(()=>{
      renderMaskedGrid(words.length);
      maskAll('已自动遮挡。如需再次查看，请重新触摸 FIDO2。');
      try{ for(let i=0;i<words.length;i++) words[i]=''; }catch{}
    }, REVEAL_MS);
  }catch(e){
    $('mask-hint').textContent = `解密失败：${e?.message||e}`;
    console.error(e);
  }
};

/* ===== C：写库（再次验证同一把凭证） ===== */
$('btn-save').onclick = async ()=>{
  const tip=$('save-tip');
  try{
    if(!sealed?.credId){ throw new Error('请先完成步骤 B'); }

    // 再做一次“同一把凭证 + 已保存 salt”的派生，相当于强制持有验证
    const salt = new Uint8Array(sealed.saltHex.match(/../g).map(h=>parseInt(h,16)));
    await deriveKEKWithSalt(sealed.credId, salt); // 仅验证可用，不再加密

    const bundle = {
      KEKInfo:{
        rp_id: sealed.rp_id,
        info: sealed.info,
        salt: sealed.saltHex,
        credential_id: sealed.credId
      },
      chains:{
        ETH:  { path: sealed.chains.ETH.path,  PubEnc: null,                PrivEnc: sealed.chains.ETH.PrivEnc  },
        BTC:  { path: sealed.chains.BTC.path,  PubEnc: null,                PrivEnc: sealed.chains.BTC.PrivEnc  },
        EOS:  { path: sealed.chains.EOS.path,  PubEnc: null,                PrivEnc: sealed.chains.EOS.PrivEnc  },
        TRON: { path: sealed.chains.TRON.path, PubEnc: null,                PrivEnc: sealed.chains.TRON.PrivEnc }
      }
    };

    tip.textContent = '正在写入数据库…';
    const resp = await fetch(`${API_BASE}/bundles`, {
      method:'POST', headers:{'content-type':'application/json'},
      body: JSON.stringify({ user_id:'web-ui', note:'init via UI', bundle })
    });
    const data = await resp.json().catch(()=> ({}));
    if(!resp.ok || !data?.ok) throw new Error(data?.error || `HTTP ${resp.status}`);

    tip.innerHTML = `<span class="ok">写入成功，bundle_id=${data.bundle_id}</span>`;
  }catch(e){
    tip.innerHTML = `<span class="err">写入失败：${e?.message||e}</span>`;
    console.error(e);
  }
};
</script>
</body>
</html>
